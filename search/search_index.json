{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>MemNNetSim: Memristive Nanowire Network Simulator. A proof-of-concept Python package for modelling and analyzing memristive random nanowire networks (NWNs). This package, developed by Marcus Kasdorf, was initiated from a summer research project in 2021 and continued to be developed under the supervision of Dr. Claudia Gomes da Rocha at the University of Calgary.</p>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Installation</li> <li>Usage</li> <li>Examples</li> <li>NWN Attributes</li> <li>Reference</li> </ul>"},{"location":"#bibliography","title":"Bibliography","text":"<p>Some main relevant papers that this work builds off of are:</p> <ul> <li>A. V. Avizienis, H. O. Sillin, C. Martin-Olmos, H. H. Shieh, M. Aono, A. Z. Stieg and J. K. Gimzewski, PLoS ONE, 2012, 7, e42772.</li> <li>D. B. Strukov, G. S. Snider, D. R. Stewart and R. S. Williams, Nature, 2008, 453, 80-83</li> <li>H. O. Sillin, R. Aguilera, H. -H. Shieh, A. V. Avizienis, M. Aono, A. Z. Stieg and J. K. Gimzewski, Nanotechnology, 2013, 24, 384004.</li> <li>L. Chen, C. Li, T. Huang, H. G. Ahmad and Y. Chen, Physics Letters A, 2014, 378, 2924-2930</li> <li>K. Fu, R. Zhu, A. Loeffler, J. Hochstetter, A. Diaz-Alvarez, A. Stieg, J. Gimzewski, T. Nakayama and Z. Kuncic, 2020 International Joint Conference on Neural Networks (IJCNN), 2020, pp. 1\u20138.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We acknowledge that this work, including the package and its supporting materials, has emanated from research supported by UCalgary Research, UCalgary Faculty of Science, the Natural Sciences and Engineering Research Council of Canada (NSERC) (USRA, Discovery Grant, and Alliance International Catalyst programs), the Quantum City initiative, and the NSERC Alliance - Alberta Innovates Advance Program (Streams I and II). We also acknowledge the Advanced Research Computing (ARC) at UCalgary, the specialized UCalgary Customer Technology Services team, the Digital Research Alliance of Canada (former Compute Canada), and CMC Microsystems for computational resources. We thank C. Soriano for the design and creation of the MemNNetSim logo and banner.</p>"},{"location":"attributes/","title":"Nanowire Network Attributes","text":"<p>Nanowire network (NWN) objects are a child class of NetworkX graphs. All the graph, node, and edge attributes are listed below. </p>"},{"location":"attributes/#nwn-graph-attributes","title":"NWN Graph Attributes","text":"<p>Attributes accessed via <code>NWN.graph[\"attribute\"]</code>. Most of these are set from the NWN constructor create_NWN().</p> <p>NanowireNetwork Attributes</p> <p>Most of the graph attributes are exposed directly as NanowireNetwork attributes or through getters/setters. The NWN graph attributes are mainly  for internal use.</p> Attribute Description <code>wire_length</code> Length of each nanowire. (l\u2080) <code>length</code> x-length of the nanowire network. (l\u2080) <code>width</code> y-length of the nanowire network. (l\u2080) <code>shape</code> Shape of the network (<code>length</code>, <code>width</code>). (l\u2080, l\u2080) <code>wire_density</code> Wire density of the network not including electrodes. (l\u2080) <code>wire_num</code> Number of wires in the network including electrodes. <code>junction_conductance</code> Conductance of the junctions. (R\u2092\u2099\u207b\u00b9) <code>wire_diameter</code> Diameter of each nanowire. (D\u2080) <code>wire_resistivity</code> Resistivity of each nanowire. (\u03c1\u2080) <code>electrode_list</code> List of electrode nodes. <code>lines</code> List of the Shapely LineStrings uses to represent the nanowires. <code>type</code> Type of nanowire network representation (<code>\"JDA\"</code> or <code>\"MNR\"</code>). <code>units</code> Dictionary of characteristic units for the NWN. See NWN Units. <code>loc</code> (JDA only) Dictionary with a two-tuple of ints as keys and Shapely Points as values. Maps junctions to their location. <code>junction_density</code> Junction density of the network. (l\u2080\u207b\u00b2) <code>node_indices</code> Dictionary with nodes as keys and indices as values. Maps nodes to a unique index."},{"location":"attributes/#nwn-nodes-attributes","title":"NWN Nodes Attributes","text":"<p>The NWN nodes  are tuples of integers. In the junction-dominated assumption (JDA) NWN graph  representation, these are one-tuples. In the multi-nodal representation (MNR)  NWN graph representation, they can either be two-tuples in the general case,  or one-tuples in the case of electrodes or wires with only one junction.</p> Attribute Description <code>electrode</code> Whether or not this node is an electrode. <code>loc</code> (MNR only) Location of the junction as a Shapely Point."},{"location":"attributes/#nwn-edges-attributes","title":"NWN Edges Attributes","text":"<p>The NWN edges  represent the junctions between nanowires for JDA NWNs, or additionally  inner-wire connections between nodes for MNR NWNs. They are just a two-tuple  of NWN Nodes.</p> Attribute Description <code>conductance</code> Conductance of the nanowire junction. <code>type</code> Either \"junction\" (JDA, MNR) or \"inner\" (MNR). <p>Using <code>NWN.set_state_var(\"name\", val)</code>, an edge attribute <code>name</code> will be added to store the state variable value <code>val</code> for all edges.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains links to examples of MemNNetSim usage.</p> <ul> <li>Hysteresis</li> <li>DC Bias</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>MemNNetSim has been tested on Python 3.10 to 3.13. It is recommended to install MemNNetSim in a virtual environment such as with venv  or conda/mamba.</p> <p>For installing locally, a pip version of 21.1  or greater is required.</p>"},{"location":"installation/#installation-from-pypi","title":"Installation from PyPI","text":"<p>Install the latest release of MemNNetSim from PyPI  using pip: <pre><code>pip install mnns\n</code></pre></p>"},{"location":"installation/#installation-for-development","title":"Installation for development","text":"<p>Download or clone the GitHub repository: <pre><code>git clone https://github.com/marcus-k/MemNNetSim.git\ncd ./MemNNetSim\n</code></pre></p> <p>Then install the package in editable mode  using pip: <pre><code>pip install -e .[dev]\n</code></pre></p> <p>To install for editing the documentation, add the <code>[docs]</code> optional dependencies: <pre><code>pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"installation/#uninstallation","title":"Uninstallation","text":"<p>Uninstall MemNNetSim using pip: <pre><code>pip uninstall mnns\n</code></pre></p>"},{"location":"installation/#testing","title":"Testing","text":"<p>MemNNetSim uses <code>pytest</code> to run the tests in the <code>tests/</code> directory and is installed when installing MemNNetSim with the <code>[dev]</code> optional dependencies.</p> <p>In the root directory of the package, run the tests with: <pre><code>pytest\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":"<p>Import MemNNetSim using: <pre><code>import mnns\n</code></pre></p>"},{"location":"usage/#creating-a-nwn","title":"Creating a NWN","text":"<p>Create a NWN with the default parameters. <pre><code>NWN = mnns.create_NWN()\n</code></pre></p> <p>The <code>create_NWN()</code> constructor has various parameters to initialize and customize it. <pre><code>NWN = mnns.create_NWN(\n    shape = (8, 5), \n    seed = 5,\n    conductance = 1.0\n)\n</code></pre></p> <p>The <code>add_electrodes()</code>  function provides different ways to add electrodes to a NWN and return their index. These are equipotential nanowires with no memristive junctions. <pre><code>left, right = mnns.add_electrodes(NWN, \"left\", \"right\")\n</code></pre></p> <p>By default, NWNs are created using the junction dominated assumption (JDA). This assumes nanowires are equipotential and have no internal resistance. Only  after all desired electrodes are added, the NWN can be converted to the  multi-nodal representation (MNR) in-place. <pre><code>NWN.to_MNR()\n</code></pre> This adds internal nanowire resistance based on the nanowire diameter and resistivity (specified when initializing the NWN) and recreates the  underlying graph object to add these additional nodes and edges. </p>"},{"location":"usage/#nwn-units","title":"NWN Units","text":"<p>MemNNetSim performs all calculations using nondimensionalized units. As such,  inputs into various MemNNetSim functions require inputs which have no units.</p> <p>To get the default units for the physical and electrical quantities: <pre><code>units = mnns.NWNUnits()\nprint(units)\n      v0: 1.0     V, Voltage\n     Ron: 10.0    \u03a9, ON Junction resistance\n      l0: 7.0     \u03bcm, Wire length\n      D0: 50.0    nm, Wire diameter\n      w0: 10.0    nm, Junction length (2x Wire coating thickness)\n    rho0: 22.6    n\u03a9m, Wire resistivity\n     mu0: 0.01    \u03bcm^2 s^-1 V^-1, Ion mobility\nRoff_Ron: 160     Off-On Resistance ratio\n      i0: 0.1     A, Current\n      t0: 10000.0 \u03bcs, Time\n</code></pre></p> <p>By passing a dictionary of units, one can change what the unit values are: <pre><code>units = mnns.NWNUnits({\"v0\": 2.0})\n</code></pre></p> <p>Derived Units</p> <p>Units <code>i0</code> and <code>t0</code> are derived units, that is, they are derived from the other base units. They cannot be set directly by passing in a dictionary like the others. Instead, you must set the units they depend on.</p> <p>They are calculated with the following formula: <pre><code>i0 = v0 / Ron\nt0 = w0**2 / (mu0 * v0)\n</code></pre></p> <p>These units can then be used when creating a NWN. <pre><code>units = mnns.NWNUnits({\"v0\": 2.0})\nNWN = mnns.create_NWN(units=units)\n</code></pre></p>"},{"location":"usage/#nwn-indices","title":"NWN Indices","text":"<p>Since MemNNetSim uses NetworkX graphs as the parent class for NWNs, the nodes and edges can still be indexed using <code>NWN.nodes</code> and <code>NWN.edges</code> respectively; however, the index labels are different depending on if the NWN is using JDA or MNR.</p> <p>For JDA NWNs, the indices used are a one-tuple of integers. <pre><code>&gt;&gt;&gt; NWN.nodes[(0,)]\n{'electrode': False}\n</code></pre> JDA nodes represent individual nanowires and edges represent a junction between nanowires.</p> <p>For MNR NWNs, the indices used are a two-tuple of integers. <pre><code>&gt;&gt;&gt; NWN.nodes[(0, 0)]\n{'loc': &lt;POINT (6.443 3.971)&gt;, 'electrode': False}\n</code></pre> MNR nodes represent specific points on a nanowire and edges represent either a junction between nanowires or an inner-nanowire connection.</p> <p>Electrode Indices</p> <p>Regardless of if a NWN is using JDA or MNR, electrodes will always be indexed using a one-tuple since by definition they are equipotential!</p> <p>Edges can then be indexed as expected. <pre><code>&gt;&gt;&gt; NWN.edges[((0, 0), ((0, 5)))]\n{'conductance': 1.7122000108743876, 'capacitance': 0, 'type': 'inner'}\n</code></pre> The <code>type</code> edge attribute stores whether the edges is an inner-nanowire connection or a nanowire junction. Currently, the <code>capacitance</code> edge attribute  is not used for anything.</p>"},{"location":"usage/#static-solution","title":"Static Solution","text":"<p>The <code>solve_network()</code> function is used to obtain the NWN nanowire voltages given the location of the source and drain nanowires and a voltage for the sources. Often, it is  desirable to use electrodes for these nodes. <pre><code>out = mnns.solve_network(NWN, left, right, voltage)\n</code></pre> If the NWN has <code>N</code> nanowires and <code>M</code> voltage sources, then the output will have the first <code>N</code> elements correspond to the nanowire voltages and the last <code>M</code> elements correspond to the current draw of the voltage sources.</p> <p>Modified Nodal Analysis</p> <p>The implemented algorithm of solving the nanowire voltages follows the modified nodal analysis scheme. More information about the algorithm can be found on the Swarthmore College website.</p>"},{"location":"usage/#dynamic-solution","title":"Dynamic Solution","text":"<p>To solve the NWN nanowire voltages over time, <code>NWN.evolve()</code>  is performed to the network. Various parameters must be set first before evolving the network. A walkthrough of an example parameters follows.</p> <p>Define the voltage and window functions. <pre><code>def voltage_func(t):\n    \"\"\"DC Voltage\"\"\"\n    V0 = 20\n    return V0 * np.ones_like(t)\n\ndef window_func(x):\n    \"\"\"Strukov window function\"\"\"\n    x = np.clip(x, 0, 1)\n    return x * (1 - x)\n</code></pre></p> <p>Define the memristive model with the desired resistance function and the  associated state variables. <pre><code>model = mnns.models.HP_model\nNWN.resistance_function = \"linear\"\nNWN.state_vars = [\"x\"]\nNWN.set_state_var(\"x\", 0.1)\n</code></pre></p> <p>Model Parameters</p> <p>For models with extra parameters, for example in the Decay HP model, they can be set with graph attributes. <pre><code>NWN.graph[\"tau\"] = 100\n</code></pre></p> <p>State Variable Order</p> <p>For models which use multiple state variables (such as <code>mnns.models.SLT_HP_model</code>), the order of <code>NWN.state_vars</code> matters! The pre-implemented linear resistance function is evaluated using the first state variable in the list.</p> <p>Define the time steps. <pre><code>min_time = 0\nmax_time = 10000\ndt = 1.0\nt_eval = np.arange(min_time, max_time, dt)\n</code></pre></p> <p>Evolve the NWN and return the state variables as a function of time. The <code>args</code> parameters is passed to the memristive model function. Evolving the network over time is perform using SciPy's <code>solve_ivp</code>  function. <code>ivp_options</code> is passed directly to there. <pre><code>tol = 1e-7\nargs = (NWN, left, right, voltage_func, window_func)\nsol = NWN.evolve(\n    model, t_eval, args=args, ivp_options={\"rtol\": tol, \"atol\": tol}\n)\n</code></pre></p> <p>Using the state variable solution, the current through each of the grounded nodes could be found by updating the state variables iteratively with the dynamic solution and solving the static case. This is implemented in <code>mnns.get_evolution_current()</code>. <pre><code>I = mnns.get_evolution_current(NWN, sol, left, right, voltage_func)\n</code></pre></p>"},{"location":"examples/dc-bias/","title":"DC Bias","text":"<p>This example analyzing the current flow passing through an output electrode when applying a positive DC voltage bias to a NWN. The nanowire junctions are evolved following the Decay HP model as the memristive model of choice.</p> <p>This can take around a minute or longer depending on the computer.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport mnns\n\n# Create a NWN\nNWN = mnns.create_NWN(\n    shape = (8, 5),\n    seed = 5, \n    density = 14.7\n)\n\n# Add four electrodes to the NWN\nbottom_l, top_l, bottom_r, top_r = mnns.add_electrodes(\n    NWN, [\"left\", 2, 1, [-0.5, 0.5]], [\"right\", 2, 1, [-0.5, 0.5]]\n)\n\n# Set model parameters\nmodel = mnns.models.decay_HP_model\nNWN.resistance_function = \"linear\"\nNWN.state_vars = [\"x\"]\nNWN.set_state_var(\"x\", 0.05)\nNWN.graph[\"tau\"] = 100\n\n# Set solver parameters\nmin_time = 0\nmax_time = 10000\ndt = 2.0\ntol = 1e-7\nt_eval = np.arange(min_time, max_time, dt)\n\n# Define the voltage waveform\ndef voltage_func(t):\n    V0 = 20\n    return np.full_like(t, V0)\n\n# Use the Strukov window function\ndef window_func(x):\n    x = np.clip(x, 0, 1)\n    return x * (1 - x)\n\n# Evolve NWN to find state variables over time\nargs = (NWN, bottom_l, top_r, voltage_func, window_func)\nsol = NWN.evolve(model, t_eval, args=args, ivp_options={\"rtol\": tol, \"atol\": tol})\n\n# Fine current though the drain electrode\nI = mnns.get_evolution_current(NWN, sol, bottom_l, top_r, voltage_func)\n\n# Scale the quantities by the right units\nscaled_V = voltage_func(sol.t) * NWN.units[\"v0\"]\nscaled_I = I * NWN.units[\"i0\"]\nscaled_t = sol.t * NWN.units[\"t0\"] * 1e-6\n\n# Plot hysteresis curve\nfig, ax = plt.subplots(figsize=(6, 4))\nax.plot(scaled_t, scaled_I * 1e3)\nax.grid(alpha=0.5)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Current (mA)\")\nplt.show()\n</code></pre> <p></p> <p> Download Jupyter notebook: dc-bias.ipynb</p> <p> Download Python file: dc-bias.py</p>"},{"location":"examples/hysteresis/","title":"Hysteresis","text":"<p>This example showcases a hysteresis plot using the HP model as the memristive model the governs the nanowire junction evolution.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport mnns\n\n# Create a NWN\nNWN = mnns.create_NWN(\n    shape = (4, 4),\n    seed = 15, \n    density = 5.875\n)\n\n# Add electrodes to the NWN\nleft, right = mnns.add_electrodes(NWN, \"left\", \"right\")\n\n# Set model parameters\nmodel = mnns.models.HP_model\nNWN.resistance_function = \"linear\"\nNWN.state_vars = [\"x\"]\nNWN.set_state_var(\"x\", 0.1)\n\n# Set solver parameters\nmin_time = 0\nmax_time = 750\ndt = 1.0\ntol = 1e-7\nt_eval = np.arange(min_time, max_time, dt)\n\n# Define the voltage waveform\ndef voltage_func(t):\n    t = np.atleast_1d(t)\n    V0 = 20\n    T = 125\n    f = 1 / T\n    phi = np.pi / 2\n\n    # Vertical translated sine wave\n    out = V0 * (np.sin(2*np.pi*f*t - phi) + 1) / 2\n\n    # Reverse the sign half way through\n    out[t &gt; max_time//2] *= -1  \n\n    return out\n\n# Define the window function\ndef window_func(x):\n    x = np.clip(x, 0, 1)\n    return x * (1 - x)\n\n# Evolve NWN to find state variables over time\nargs = (NWN, left, right, voltage_func, window_func)\nsol = NWN.evolve(model, t_eval, args=args, ivp_options={\"rtol\": tol, \"atol\": tol})\n\n# Fine current though the drain electrode\nI = mnns.get_evolution_current(NWN, sol, left, right, voltage_func)\n\n# Scale the quantities by the right units\nscaled_V = voltage_func(sol.t) * NWN.units[\"v0\"]\nscaled_I = I * NWN.units[\"i0\"]\nscaled_t = sol.t * NWN.units[\"t0\"] * 1e-6\n\n# Plot hysteresis curve\nfig, ax = plt.subplots(figsize=(6, 4))\nax.plot(scaled_V, scaled_I * 1e3)\nax.grid(alpha=0.5)\nax.set_xlabel(\"Voltage (V)\")\nax.set_ylabel(\"Current (mA)\")\nplt.show()\n</code></pre> <p></p> <p> Download Jupyter notebook: hysteresis.ipynb</p> <p> Download Python file: hysteresis.py</p>"},{"location":"reference/mnns/","title":"mnns","text":""},{"location":"reference/mnns/#mnns","title":"mnns","text":"<p>MemNNetSim: Memristive Nanowire Network Simulator. A proof-of-concept Python package for modelling and analyzing memristive random nanowire networks (NWNs).</p> <p>Import MemNNetSim using: <pre><code>import mnns\n</code></pre></p> <p>Modules:</p> Name Description <code>calculations</code> <p>Functions to statically solve nanowire networks.</p> <code>dynamics</code> <p>Functions to evolve nanowire networks over time.</p> <code>fromtext</code> <p>Not for production. Functions to create nanowire networks from text file.</p> <code>line_functions</code> <p>Functions for random lines.</p> <code>models</code> <p>Various dynamic models for nanowire networks.</p> <code>nanowire_network</code> <p>Functions to create nanowire networks.</p> <code>nanowires</code> <p>Functions to modify nanowire networks.</p> <code>plotting</code> <p>Functions to plot nanowire networks.</p> <code>units</code> <p>Characteristic units for a nanowire network.</p>"},{"location":"reference/mnns/calculations/","title":"mnns.calculations","text":""},{"location":"reference/mnns/calculations/#mnns.calculations","title":"mnns.calculations","text":"<p>Functions to statically solve nanowire networks.</p> <p>Functions:</p> Name Description <code>create_matrix</code> <p>Create the Laplacian connectivity matrix.</p> <code>get_connected_nodes</code> <p>Returns a list of nodes which are connected to any of the given nodes.</p> <code>scale_sol</code> <p>Scale the voltage and current solutions by their characteristic values.</p> <code>solve_drain_current</code> <p>Solve for the current through each drain node of a NWN.</p> <code>solve_edge_current</code> <p>Solve for the current passing through each edge of a NWN. The direction is</p> <code>solve_network</code> <p>Solve for the voltages of each node in a given NWN. Each drain node will</p> <code>solve_nodal_current</code> <p>Solve for the current entering each node of a NWN. Only the entering</p>"},{"location":"reference/mnns/calculations/#mnns.calculations.create_matrix","title":"create_matrix","text":"<pre><code>create_matrix(\n    NWN: NanowireNetwork,\n    value_type: str = \"conductance\",\n    source_nodes: list[NWNNode] = None,\n    drain_nodes: list[NWNNode] = None,\n    ground_nodes: bool = False,\n) -&gt; scipy.sparse.csr_matrix\n</code></pre> <p>Create the Laplacian connectivity matrix.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>value_type</code> <code>('conductance', 'capacitance')</code> <p>Weight to use for the Laplacian matrix. Default: \"conductance\".</p> <code>\"conductance\"</code> <code>source_nodes</code> <code>list of tuples</code> <p>Only needed if ground_nodes is True to find which nodes are to be grounded. Default: None.</p> <code>None</code> <code>drain_nodes</code> <code>list of tuples</code> <p>If a drain node is supplied, the row and column corresponding to the drain node are zeros and a one is placed at the row-column intersection. Default: None.</p> <code>None</code> <code>ground_nodes</code> <code>bool</code> <p>If true, a small value is added to the main diagonal to avoid singular matrices. Default: False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>M</code> <code>csr_matrix</code> <p>Resultant sparse Laplacian matrix.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def create_matrix(\n    NWN: NanowireNetwork,\n    value_type: str = \"conductance\",\n    source_nodes: list[NWNNode] = None,\n    drain_nodes: list[NWNNode] = None,\n    ground_nodes: bool = False,\n) -&gt; scipy.sparse.csr_matrix:\n    \"\"\"\n    Create the Laplacian connectivity matrix.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    value_type : {\"conductance\", \"capacitance\"}, optional\n        Weight to use for the Laplacian matrix. Default: \"conductance\".\n\n    source_nodes : list of tuples, optional\n        Only needed if ground_nodes is True to find which nodes are to be\n        grounded. Default: None.\n\n    drain_nodes : list of tuples, optional\n        If a drain node is supplied, the row and column corresponding to\n        the drain node are zeros and a one is placed at the row-column\n        intersection. Default: None.\n\n    ground_nodes : bool, optional\n        If true, a small value is added to the main diagonal to avoid\n        singular matrices. Default: False.\n\n    Returns\n    -------\n    M : csr_matrix\n        Resultant sparse Laplacian matrix.\n\n    \"\"\"\n    # Error check\n    TYPES = [\"conductance\", \"capacitance\"]\n    if value_type not in TYPES:\n        raise ValueError(\"Invalid matrix type.\")\n\n    # Default values\n    if source_nodes is None:\n        source_nodes = []\n    if drain_nodes is None:\n        drain_nodes = []\n\n    # Get Laplacian matrix\n    nodelist = NWN.graph[\"node_indices\"].keys()\n    nodelist_len = len(nodelist)\n    M = laplacian_matrix(NWN, nodelist=nodelist, weight=value_type)\n\n    # Ground every node with a huge resistor/tiny capacitor\n    if ground_nodes:\n        # Get list of node indices which are not connected to an electrode\n        unconnected_indices = list(\n            set(NWN.graph[\"node_indices\"].values()).difference(\n                set(\n                    NWN.graph[\"node_indices\"][node]\n                    for node in get_connected_nodes(\n                        NWN, [*source_nodes, *drain_nodes]\n                    )\n                )\n            )\n        )\n\n        small = np.zeros(nodelist_len)\n        small[unconnected_indices] = 1e-12\n\n        # Add small value to diagonal, grounding all non-connected nodes\n        M += scipy.sparse.dia_matrix(\n            (small, [0]), shape=(nodelist_len, nodelist_len)\n        )\n\n    # Zero each of the drain nodes' row and column\n    for drain in drain_nodes:\n        # Change to lil since csr sparsity changes are expensive\n        M = M.tolil()\n        drain_index = NWN.graph[\"node_indices\"][drain]\n        M[drain_index] = 0\n        M[:, drain_index] = 0\n        M[drain_index, drain_index] = 1\n\n    return M.tocsr()\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.get_connected_nodes","title":"get_connected_nodes","text":"<pre><code>get_connected_nodes(\n    NWN: NanowireNetwork, connected: list[NWNNode]\n) -&gt; set[NWNNode]\n</code></pre> <p>Returns a list of nodes which are connected to any of the given nodes.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def get_connected_nodes(\n    NWN: NanowireNetwork, connected: list[NWNNode]\n) -&gt; set[NWNNode]:\n    \"\"\"\n    Returns a list of nodes which are connected to any of the given nodes.\n\n    \"\"\"\n    nodelist = set()\n    for subset in nx.connected_components(NWN):\n        if any(node in subset for node in connected):\n            nodelist = nodelist.union(subset)\n    return nodelist\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.scale_sol","title":"scale_sol","text":"<pre><code>scale_sol(\n    NWN: NanowireNetwork, sol: NDArray\n) -&gt; npt.NDArray\n</code></pre> <p>Scale the voltage and current solutions by their characteristic values.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def scale_sol(NWN: NanowireNetwork, sol: npt.NDArray) -&gt; npt.NDArray:\n    \"\"\"\n    Scale the voltage and current solutions by their characteristic values.\n\n    \"\"\"\n    # Get parameters\n    out = np.copy(sol)\n    v0 = NWN.graph[\"units\"][\"v0\"]\n    i0 = NWN.graph[\"units\"][\"i0\"]\n    node_num = len(NWN.graph[\"node_indices\"])\n\n    # Current sources\n    if node_num == len(sol):\n        out *= v0\n\n    # Voltage sources\n    else:\n        out[:node_num] *= v0\n        out[node_num:] *= i0\n\n    return out\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.solve_drain_current","title":"solve_drain_current","text":"<pre><code>solve_drain_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Solve for the current through each drain node of a NWN.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>voltage</code> <code>float</code> <p>Voltage of the source nodes.</p> required <code>scaled</code> <code>bool</code> <p>Whether or not to scaled the output by i0. Default: False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <p>Returns:</p> Name Type Description <code>current_array</code> <code>ndarray</code> <p>Array containing the current flow through each drain node in the order passed.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def solve_drain_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Solve for the current through each drain node of a NWN.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    source_node : tuple, or list of tuples\n        Voltage source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    voltage : float\n        Voltage of the source nodes.\n\n    scaled : bool, optional\n        Whether or not to scaled the output by i0. Default: False.\n\n    solver: str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    Returns\n    -------\n    current_array : ndarray\n        Array containing the current flow through each drain node in the order\n        passed.\n\n    \"\"\"\n    # Get lists of source and drain nodes\n    if isinstance(source_node, tuple):\n        source_node = [source_node]\n    if isinstance(drain_node, tuple):\n        drain_node = [drain_node]\n\n    # Preallocate output\n    current_array = np.zeros(len(drain_node))\n\n    # Solve nodes\n    out = solve_network(\n        NWN, source_node, drain_node, voltage, \"voltage\", solver, **kwargs\n    )\n\n    # Find current through each drain node\n    for i, drain in enumerate(drain_node):\n        I = 0\n        for node in NWN.neighbors(drain):\n            V = out[NWN.get_index(node)]\n            R = 1 / NWN.edges[(node, drain)][\"conductance\"]\n            I += V / R\n        current_array[i] = I\n\n    # Scale the output if desired\n    if scaled:\n        current_array *= NWN.graph[\"units\"][\"i0\"]\n\n    return current_array.squeeze()\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.solve_edge_current","title":"solve_edge_current","text":"<pre><code>solve_edge_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Solve for the current passing through each edge of a NWN. The direction is not considered, only the magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>voltage</code> <code>float</code> <p>Voltage of the source nodes.</p> required <code>scaled</code> <code>bool</code> <p>Whether or not to scaled the output by i0. Default: False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <p>Returns:</p> Name Type Description <code>I</code> <code>ndarray</code> <p>Array containing the current flow through each edge.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def solve_edge_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Solve for the current passing through each edge of a NWN. The direction is\n    not considered, only the magnitude.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    source_node : tuple, or list of tuples\n        Voltage source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    voltage : float\n        Voltage of the source nodes.\n\n    scaled : bool, optional\n        Whether or not to scaled the output by i0. Default: False.\n\n    solver: str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    Returns\n    -------\n    I : ndarray\n        Array containing the current flow through each edge.\n\n    \"\"\"\n    # Get nodal voltages\n    sol = solve_network(\n        NWN, source_node, drain_node, voltage, \"voltage\", solver, **kwargs\n    )\n\n    # Get edges and conductances\n    edges, G = zip(*nx.get_edge_attributes(NWN, \"conductance\").items())\n\n    # Find edges indices\n    start_nodes, end_nodes = get_edge_indices(NWN, edges)\n\n    # Find current through each edges\n    v0 = sol[start_nodes]\n    v1 = sol[end_nodes]\n    V_delta = np.abs(v0 - v1)\n    I = V_delta * G\n\n    # Scale the output if desired\n    if scaled:\n        I *= NWN.graph[\"units\"][\"i0\"]\n\n    return I\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.solve_network","title":"solve_network","text":"<pre><code>solve_network(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    input: float,\n    type: str = \"voltage\",\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Solve for the voltages of each node in a given NWN. Each drain node will be grounded. If the type is \"voltage\", each source node will be at the specified input voltage. If the type is \"current\", current will be sourced from each source node.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage/current source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>input</code> <code>float</code> <p>Supplied voltage (current) in units of v0 (i0).</p> required <code>type</code> <code>('voltage', 'current')</code> <p>Input type. Default: \"voltage\".</p> <code>\"voltage\"</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <code>**kwargs</code> <p>Keyword arguments passed to the solver.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>out</code> <code>ndarray</code> <p>Output array containing the voltages of each node. If the input type is voltage, the current is also in this array as the last element.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def solve_network(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    input: float,\n    type: str = \"voltage\",\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Solve for the voltages of each node in a given NWN. Each drain node will\n    be grounded. If the type is \"voltage\", each source node will be at the\n    specified input voltage. If the type is \"current\", current will be sourced\n    from each source node.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    source_node : tuple, or list of tuples\n        Voltage/current source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    input : float\n        Supplied voltage (current) in units of v0 (i0).\n\n    type : {\"voltage\", \"current\"}, optional\n        Input type. Default: \"voltage\".\n\n    solver: str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    **kwargs\n        Keyword arguments passed to the solver.\n\n    Returns\n    -------\n    out : ndarray\n        Output array containing the voltages of each node. If the input type\n        is voltage, the current is also in this array as the last element.\n\n    \"\"\"\n    # Get lists of source and drain nodes\n    if isinstance(source_node, tuple):\n        source_node = [source_node]\n    if isinstance(drain_node, tuple):\n        drain_node = [drain_node]\n\n    # Pass to solvers\n    if type == \"voltage\":\n        out = _solve_voltage(\n            NWN, input, source_node, drain_node, solver, **kwargs\n        )\n    elif type == \"current\":\n        out = _solve_current(\n            NWN, input, source_node, drain_node, solver, **kwargs\n        )\n    else:\n        raise ValueError(\"Invalid source type.\")\n\n    return out\n</code></pre>"},{"location":"reference/mnns/calculations/#mnns.calculations.solve_nodal_current","title":"solve_nodal_current","text":"<pre><code>solve_nodal_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Solve for the current entering each node of a NWN. Only the entering current is considered since by Kirchoff's law, the sum of currents entering a node must equal the sum of currents leaving a node.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>voltage</code> <code>float</code> <p>Voltage of the source nodes.</p> required <code>scaled</code> <code>bool</code> <p>Whether or not to scaled the output by i0. Default: False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <p>Returns:</p> Name Type Description <code>current_array</code> <code>ndarray</code> <p>Array containing the current flow entering each node.</p> Source code in <code>mnns/calculations.py</code> <pre><code>def solve_nodal_current(\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage: float,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Solve for the current entering each node of a NWN. Only the entering\n    current is considered since by Kirchoff's law, the sum of currents\n    entering a node must equal the sum of currents leaving a node.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    source_node : tuple, or list of tuples\n        Voltage source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    voltage : float\n        Voltage of the source nodes.\n\n    scaled : bool, optional\n        Whether or not to scaled the output by i0. Default: False.\n\n    solver: str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    Returns\n    -------\n    current_array : ndarray\n        Array containing the current flow entering each node.\n\n    \"\"\"\n    # Get nodal voltages\n    V_out = solve_network(\n        NWN, source_node, drain_node, voltage, \"voltage\", solver, **kwargs\n    )\n\n    # Preallocate output\n    current_array = np.zeros(len(NWN.nodes))\n\n    # Calculate input current for each node\n    for node in NWN.nodes:\n        node_ind = NWN.graph[\"node_indices\"][node]\n        for edge in NWN.edges(node):\n            edge0_ind = NWN.graph[\"node_indices\"][edge[0]]\n            edge1_ind = NWN.graph[\"node_indices\"][edge[1]]\n            V_delta = V_out[edge1_ind] - V_out[edge0_ind]\n\n            # Only add current entering a node so we can see how much\n            # current passes through. Else, we just get zero due to KCL.\n            if V_delta &gt; 0:\n                current_array[node_ind] += (\n                    V_delta * NWN.edges[edge][\"conductance\"] * np.sign(voltage)\n                )\n\n    # Scale the output if desired\n    if scaled:\n        current_array *= NWN.graph[\"units\"][\"i0\"]\n\n    return current_array\n</code></pre>"},{"location":"reference/mnns/dynamics/","title":"mnns.dynamics","text":""},{"location":"reference/mnns/dynamics/#mnns.dynamics","title":"mnns.dynamics","text":"<p>Functions to evolve nanowire networks over time.</p> <p>Functions:</p> Name Description <code>get_evolution_current</code> <p>Calculates the current draw from each drain node as a function of time,</p> <code>get_evolution_node_voltages</code> <p>To be used in conjunction with <code>solve_evolution</code>. Takes the output from</p> <code>set_state_variables</code> <p>Deprecated. Please use NanowireNetwork.set_state_var() instead.</p> <code>solve_evolution</code> <p>Deprecated. Please use NanowireNetwork.evolve() instead.</p>"},{"location":"reference/mnns/dynamics/#mnns.dynamics.get_evolution_current","title":"get_evolution_current","text":"<pre><code>get_evolution_current(\n    NWN: NanowireNetwork,\n    sol: OdeResult,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    state_vars: Optional[list[str]] = None,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Calculates the current draw from each drain node as a function of time, given the output state variables from <code>NWN.evolve()</code>.</p> <p>The source, drain, and voltage are expected to be the same as in the evolution of the state variables.</p> <p>This assumes the resistance function only depends on the first state variable set.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>NanowireNetwork</code> <p>Nanowire network.</p> required <code>sol</code> <code>OdeResult</code> <p>Output state variables from <code>NWN.evolve()</code>.</p> required <code>source_node</code> <code>NWNNode, or list of NWNNodes</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>NWNNode, or list of NWNNodes</code> <p>Grounded output nodes.</p> required <code>voltage_func</code> <code>Callable</code> <p>Function which inputs the time as a scalar and returns the voltage of all the source nodes as a scalar. Should be dimensionless.</p> required <code>state_vars</code> <code>list of str</code> <p>List of state variables to use. Should not need to be provided. Defaults to <code>NWN.state_vars</code>.</p> <code>None</code> <code>scaled</code> <code>bool</code> <p>Scale the output by the characteristic values. Default: False.</p> <code>False</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <code>**kwargs</code> <p>Keyword arguments passed to the solver.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>current_array</code> <code>ndarray</code> <p>Array containing the current flow through each drain node. Each column corresponds to a drain node in the order passed.</p> Source code in <code>mnns/dynamics.py</code> <pre><code>def get_evolution_current(\n    NWN: NanowireNetwork,\n    sol: OdeResult,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    state_vars: Optional[list[str]] = None,\n    scaled: bool = False,\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Calculates the current draw from each drain node as a function of time,\n    given the output state variables from `NWN.evolve()`.\n\n    The source, drain, and voltage are expected to be the same as in the\n    evolution of the state variables.\n\n    This assumes the resistance function only depends on the first state variable\n    set.\n\n    Parameters\n    ----------\n    NWN : NanowireNetwork\n        Nanowire network.\n\n    sol : OdeResult\n        Output state variables from `NWN.evolve()`.\n\n    source_node : NWNNode, or list of NWNNodes\n        Voltage source nodes.\n\n    drain_node : NWNNode, or list of NWNNodes\n        Grounded output nodes.\n\n    voltage_func : Callable\n        Function which inputs the time as a scalar and returns the voltage of\n        all the source nodes as a scalar. Should be dimensionless.\n\n    state_vars : list of str, optional\n        List of state variables to use. Should not need to be provided.\n        Defaults to `NWN.state_vars`.\n\n    scaled : bool, optional\n        Scale the output by the characteristic values. Default: False.\n\n    solver : str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    **kwargs\n        Keyword arguments passed to the solver.\n\n    Returns\n    -------\n    current_array: ndarray\n        Array containing the current flow through each drain node. Each column\n        corresponds to a drain node in the order passed.\n\n    \"\"\"\n    # Get lists of source and drain nodes\n    if isinstance(source_node, tuple):\n        source_node = [source_node]\n    if isinstance(drain_node, tuple):\n        drain_node = [drain_node]\n\n    if state_vars is None:\n        state_vars = NWN.state_vars\n\n    # Preallocate output\n    current_array = np.zeros((len(sol.t), len(drain_node)))\n\n    # Loop through each time step\n    for i, state in enumerate(sol.y.T):\n\n        # Set state variables\n        split = np.split(state, len(state_vars))\n        for j, var in enumerate(state_vars):\n            NWN.set_state_var(var, split[j])\n\n        # Update resistance\n        NWN.update_resistance(split[0])\n\n        # Find current draw through drain nodes\n        V = voltage_func(sol.t[i])\n        current_array[i] = solve_drain_current(\n            NWN, source_node, drain_node, V, scaled, solver, **kwargs\n        )\n\n    return current_array.squeeze()\n</code></pre>"},{"location":"reference/mnns/dynamics/#mnns.dynamics.get_evolution_node_voltages","title":"get_evolution_node_voltages","text":"<pre><code>get_evolution_node_voltages(\n    NWN: Graph,\n    sol: OdeResult,\n    edge_list: list[NWNEdge],\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>To be used in conjunction with <code>solve_evolution</code>. Takes the output from <code>solve_evolution</code> and finds the voltage of all nodes in the network at each time step.</p> <p>The appropriate parameters passed should be the same as <code>solve_evolution</code>.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>sol</code> <code>OdeResult</code> <p>Output from <code>solve_evolution</code>.</p> required <code>edge_list</code> <code>list of tuples</code> <p>Output from <code>solve_evolution</code>.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>voltage_func</code> <code>Callable</code> <p>The applied voltage with the calling signature <code>func(t)</code>. The voltage should have units of <code>v0</code>.</p> required <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <code>**kwargs</code> <p>Keyword arguments passed to the solver.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>node_voltage_array</code> <code>ndarray</code> <p>An <code>n</code> x <code>m</code> array containing the voltage of each node in the network, corresponding to the <code>n</code> time steps and <code>m</code> nodes in the network.</p> Source code in <code>mnns/dynamics.py</code> <pre><code>def get_evolution_node_voltages(\n    NWN: nx.Graph,\n    sol: OdeResult,\n    edge_list: list[NWNEdge],\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; npt.NDArray:\n    \"\"\"\n    To be used in conjunction with `solve_evolution`. Takes the output from\n    `solve_evolution` and finds the voltage of all nodes in the network at each\n    time step.\n\n    The appropriate parameters passed should be the same as `solve_evolution`.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    sol : OdeResult\n        Output from `solve_evolution`.\n\n    edge_list : list of tuples\n        Output from `solve_evolution`.\n\n    source_node : tuple, or list of tuples\n        Voltage source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    voltage_func : Callable\n        The applied voltage with the calling signature `func(t)`. The voltage\n        should have units of `v0`.\n\n    solver : str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    **kwargs\n        Keyword arguments passed to the solver.\n\n    Returns\n    -------\n    node_voltage_array: ndarray\n        An `n` x `m` array containing the voltage of each node in the network,\n        corresponding to the `n` time steps and `m` nodes in the network.\n\n    \"\"\"\n    # Get lists of source and drain nodes\n    if isinstance(source_node, tuple):\n        source_node = [source_node]\n    if isinstance(drain_node, tuple):\n        drain_node = [drain_node]\n\n    # Preallocate output\n    node_voltage_array = np.zeros((len(sol.t), len(NWN.nodes)))\n\n    # Loop through each time step\n    for i in range(len(sol.t)):\n        # Set state variables and get drain currents\n        input_V = voltage_func(sol.t[i])\n        set_state_variables(NWN, sol.y.T[i], edge_list)\n        *node_voltage_array[i], I = solve_network(\n            NWN, source_node, drain_node, input_V, \"voltage\", solver, **kwargs\n        )\n\n    return node_voltage_array.squeeze()\n</code></pre>"},{"location":"reference/mnns/dynamics/#mnns.dynamics.set_state_variables","title":"set_state_variables","text":"<pre><code>set_state_variables(NWN: NanowireNetwork, *args)\n</code></pre> <p>Deprecated. Please use NanowireNetwork.set_state_var() instead.</p> <p>Sets the given nanowire network's state variable. Can be called in the following ways:</p> <pre><code>set_state_variables(NWN, w)\n    where `w` is a scalar value which is set for all edges.\n\nset_state_variables(NWN, w, edge_list)\n    where `w` is an ndarray and edge_list is a list. The `w` array\n    contains the state variable for the corresponding edge in\n    `edge_list`.\n\nset_state_variables(NWN, w, tau)\n    where `w` and `tau` are scalar values which is set for all edges.\n\nset_state_variables(NWN, w, tau, edge_list)\n    where `w` and `tau` are ndarrays and edge_list is a list. The `w`\n    and `tau` arrays contains the state variables for the\n    corresponding edge in `edge_list`.\n\nset_state_variables(NWN, w, tau, epsilon)\n    where `w`, `tau`, and `epsilon` are scalar values which is set for\n    all edges.\n\nset_state_variables(NWN, w, tau, epsilon, edge_list)\n    where `w`,`tau`, and `epsilon` are ndarrays and edge_list is a list.\n    The `w`,`tau`, and `epsilon` arrays contains the state variables\n    for the corresponding edge in `edge_list`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>NanowireNetwork</code> <p>Nanowire network.</p> required <code>*args</code> <p>See above.</p> <code>()</code> Source code in <code>mnns/dynamics.py</code> <pre><code>def set_state_variables(NWN: NanowireNetwork, *args):\n    \"\"\"\n    Deprecated. Please use NanowireNetwork.set_state_var() instead.\n\n    Sets the given nanowire network's state variable. Can be called in the\n    following ways:\n\n        set_state_variables(NWN, w)\n            where `w` is a scalar value which is set for all edges.\n\n        set_state_variables(NWN, w, edge_list)\n            where `w` is an ndarray and edge_list is a list. The `w` array\n            contains the state variable for the corresponding edge in\n            `edge_list`.\n\n        set_state_variables(NWN, w, tau)\n            where `w` and `tau` are scalar values which is set for all edges.\n\n        set_state_variables(NWN, w, tau, edge_list)\n            where `w` and `tau` are ndarrays and edge_list is a list. The `w`\n            and `tau` arrays contains the state variables for the\n            corresponding edge in `edge_list`.\n\n        set_state_variables(NWN, w, tau, epsilon)\n            where `w`, `tau`, and `epsilon` are scalar values which is set for\n            all edges.\n\n        set_state_variables(NWN, w, tau, epsilon, edge_list)\n            where `w`,`tau`, and `epsilon` are ndarrays and edge_list is a list.\n            The `w`,`tau`, and `epsilon` arrays contains the state variables\n            for the corresponding edge in `edge_list`.\n\n    Parameters\n    ----------\n    NWN: Graph\n        Nanowire network.\n\n    *args\n        See above.\n\n    \"\"\"\n    # Only scalar w passed\n    if len(args) == 1:\n        if isinstance(args[0], Number):\n            w = args[0]\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\"w\": w, \"conductance\": 1 / R}\n                for edge in NWN.edges\n                if NWN.edges[edge][\"type\"] == \"junction\"\n            }\n            nx.set_edge_attributes(NWN, attrs)\n\n        else:\n            raise ValueError(\"Invalid arguments.\")\n\n    elif len(args) == 2:\n        # vector w and edge_list passed\n        if isinstance(args[0], np.ndarray) and isinstance(args[1], Iterable):\n            w, edge_list = args\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\"w\": w[i], \"conductance\": 1 / R[i]}\n                for i, edge in enumerate(edge_list)\n            }\n            nx.set_edge_attributes(NWN, attrs)\n\n        # scalar w and scalar tau passed\n        elif isinstance(args[0], Number) and isinstance(args[1], Number):\n            w, tau = args\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\"w\": w, \"conductance\": 1 / R, \"tau\": tau}\n                for edge in NWN.edges\n                if NWN.edges[edge][\"type\"] == \"junction\"\n            }\n            nx.set_edge_attributes(NWN, attrs)\n            NWN.graph[\"tau\"] = tau\n\n        else:\n            raise ValueError(\"Invalid arguments.\")\n\n    elif len(args) == 3:\n        # vector w, vector tau, and edge_list passed\n        if (\n            isinstance(args[0], np.ndarray)\n            and isinstance(args[1], np.ndarray)\n            and isinstance(args[2], Iterable)\n        ):\n            w, tau, edge_list = args\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\"w\": w[i], \"conductance\": 1 / R[i], \"tau\": tau[i]}\n                for i, edge in enumerate(edge_list)\n            }\n            nx.set_edge_attributes(NWN, attrs)\n\n        # scalar w, scalar tau, scalar epsilon passed\n        if (\n            isinstance(args[0], Number)\n            and isinstance(args[1], Number)\n            and isinstance(args[2], Number)\n        ):\n            w, tau, epsilon = args\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\n                    \"w\": w,\n                    \"conductance\": 1 / R,\n                    \"tau\": tau,\n                    \"epsilon\": epsilon,\n                }\n                for edge in NWN.edges\n                if NWN.edges[edge][\"type\"] == \"junction\"\n            }\n            nx.set_edge_attributes(NWN, attrs)\n            NWN.graph[\"tau\"] = tau\n            NWN.graph[\"epsilon\"] = epsilon\n\n        else:\n            raise ValueError(\"Invalid arguments.\")\n\n    elif len(args) == 4:\n        # vector w, vector tau, vector epsilon, and edge_list passed\n        if (\n            isinstance(args[0], np.ndarray)\n            and isinstance(args[1], np.ndarray)\n            and isinstance(args[2], np.ndarray)\n            and isinstance(args[3], Iterable)\n        ):\n            w, tau, epsilon, edge_list = args\n            R = models.resist_func(NWN, w)\n\n            attrs = {\n                edge: {\n                    \"w\": w[i],\n                    \"conductance\": 1 / R[i],\n                    \"tau\": tau[i],\n                    \"epsilon\": epsilon[i],\n                }\n                for i, edge in enumerate(edge_list)\n            }\n            nx.set_edge_attributes(NWN, attrs)\n\n        else:\n            raise ValueError(\"Invalid arguments.\")\n\n    else:\n        raise ValueError(\"Invalid number of arguments.\")\n</code></pre>"},{"location":"reference/mnns/dynamics/#mnns.dynamics.solve_evolution","title":"solve_evolution","text":"<pre><code>solve_evolution(\n    NWN: NanowireNetwork,\n    t_eval: NDArray,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable = None,\n    tol: float = 1e-12,\n    model: str = \"default\",\n    solver: str = \"spsolve\",\n    **kwargs\n) -&gt; tuple[OdeResult, list[NWNEdge]]\n</code></pre> <p>Deprecated. Please use NanowireNetwork.evolve() instead.</p> <p>Solve for the state variables <code>w</code> of the junctions of the given nanowire network at various points in time with an applied voltage.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>NanowireNetwork</code> <p>Nanowire network.</p> required <code>t_eval</code> <code>ndarray</code> <p>Time points to evaluate the nanowire network at. These should have units of <code>t0</code>.</p> required <code>source_node</code> <code>tuple, or list of tuples</code> <p>Voltage source nodes.</p> required <code>drain_node</code> <code>tuple, or list of tuples</code> <p>Grounded output nodes.</p> required <code>voltage_func</code> <code>Callable</code> <p>The applied voltage with the calling signature <code>func(t)</code>. The voltage should have units of <code>v0</code>.</p> required <code>window_func</code> <code>Callable</code> <p>The window function used in the derivative of <code>w</code>. The calling signature is <code>f(w)</code> where w is the array of state variables. The default window function is <code>f(w) = 1</code>.</p> <code>None</code> <code>tol</code> <code>float</code> <p>Tolerance of <code>scipy.integrate.solve_ivp</code>. Defaults to 1e-12.</p> <code>1e-12</code> <code>model</code> <code>(default, decay, chen)</code> <p>Evolutionary model type. Default: \"default\".</p> <code>\"default\"</code> <code>solver</code> <code>str</code> <p>Name of sparse matrix solving algorithm to use. Default: \"spsolve\".</p> <code>'spsolve'</code> <code>**kwargs</code> <p>Keyword arguments passed to the solver.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>sol</code> <code>OdeResult</code> <p>Output from <code>scipy.integrate.solve_ivp</code>. See the SciPy documentation for information on this output's formatting.</p> <code>edge_list</code> <code>list of tuples</code> <p>List of the edges corresponding with each <code>w</code>.</p> Source code in <code>mnns/dynamics.py</code> <pre><code>def solve_evolution(\n    NWN: NanowireNetwork,\n    t_eval: npt.NDArray,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable = None,\n    tol: float = 1e-12,\n    model: str = \"default\",\n    solver: str = \"spsolve\",\n    **kwargs,\n) -&gt; tuple[OdeResult, list[NWNEdge]]:\n    \"\"\"\n    Deprecated. Please use NanowireNetwork.evolve() instead.\n\n    Solve for the state variables `w` of the junctions of the given nanowire\n    network at various points in time with an applied voltage.\n\n    Parameters\n    ----------\n    NWN: Graph\n        Nanowire network.\n\n    t_eval : ndarray\n        Time points to evaluate the nanowire network at. These should have\n        units of `t0`.\n\n    source_node : tuple, or list of tuples\n        Voltage source nodes.\n\n    drain_node : tuple, or list of tuples\n        Grounded output nodes.\n\n    voltage_func : Callable\n        The applied voltage with the calling signature `func(t)`. The voltage\n        should have units of `v0`.\n\n    window_func : Callable, optional\n        The window function used in the derivative of `w`. The calling\n        signature is `f(w)` where w is the array of state variables.\n        The default window function is `f(w) = 1`.\n\n    tol : float, optional\n        Tolerance of `scipy.integrate.solve_ivp`. Defaults to 1e-12.\n\n    model : {\"default\", \"decay\", \"chen\"}, optional\n        Evolutionary model type. Default: \"default\".\n\n    solver : str, optional\n        Name of sparse matrix solving algorithm to use. Default: \"spsolve\".\n\n    **kwargs\n        Keyword arguments passed to the solver.\n\n    Returns\n    -------\n    sol : OdeResult\n        Output from `scipy.integrate.solve_ivp`. See the SciPy documentation\n        for information on this output's formatting.\n\n    edge_list : list of tuples\n        List of the edges corresponding with each `w`.\n\n    \"\"\"\n    if model not in (\"default\", \"HP\", \"decay\", \"chen\", \"SLT\"):\n        raise ValueError(f'Unsupported model type: model=\"{model}\"')\n\n    # Default window function\n    if window_func is None:\n        window_func = lambda x: 1\n\n    # Get list of junction edges and state variable w\n    edge_list, w0 = map(\n        list,\n        zip(*[((u, v), w) for u, v, w in NWN.edges.data(\"w\") if w is not None]),\n    )\n\n    # Get edge indices\n    start_nodes, end_nodes = get_edge_indices(NWN, edge_list)\n\n    # Get list of tau\n    tau0 = [tau for _, _, tau in NWN.edges.data(\"tau\") if tau is not None]\n\n    # Get list of epsilon\n    epsilon0 = [ep for _, _, ep in NWN.edges.data(\"epsilon\") if ep is not None]\n\n    # Define initial state and associated derivative\n    if model == \"default\" or model == \"HP\":\n        _deriv = models.HP_model\n        y0 = w0\n    elif model == \"decay\":\n        _deriv = models.decay_HP_model\n        y0 = w0\n    elif model == \"chen\" or model == \"SLT\":\n        _deriv = models.SLT_HP_model\n        y0 = np.hstack((w0, tau0, epsilon0))\n        if \"sigma\" not in NWN.graph.keys():\n            raise AttributeError(\n                \"sigma, theta, and a must be set before using the Chen model.\"\n            )\n\n    # Solve the system of ODEs\n    t_span = (t_eval[0], t_eval[-1])\n    sol = solve_ivp(\n        _deriv,\n        t_span,\n        y0,\n        \"DOP853\",\n        t_eval,\n        atol=tol,\n        rtol=tol,\n        args=(\n            NWN,\n            source_node,\n            drain_node,\n            voltage_func,\n            window_func,\n            solver,\n            kwargs,\n        ),\n    )\n\n    # Update NWN to final state variables.\n    if model == \"default\":\n        set_state_variables(NWN, sol.y[:, -1], edge_list)\n    elif model == \"decay\":\n        set_state_variables(NWN, sol.y[:, -1], edge_list)\n    elif model == \"chen\":\n        w_list, tau_list, eps_list = np.split(sol.y, 3)\n        set_state_variables(\n            NWN, w_list[:, -1], tau_list[:, -1], eps_list[:, -1], edge_list\n        )\n\n    return sol, edge_list\n</code></pre>"},{"location":"reference/mnns/fromtext/","title":"mnns.fromtext","text":""},{"location":"reference/mnns/fromtext/#mnns.fromtext","title":"mnns.fromtext","text":"<p>Not for production. Functions to create nanowire networks from text file.</p> <p>Functions:</p> Name Description <code>create_NWN_from_txt</code> <p>Create a nanowire network represented by a NetworkX graph. Wires are</p>"},{"location":"reference/mnns/fromtext/#mnns.fromtext.create_NWN_from_txt","title":"create_NWN_from_txt","text":"<pre><code>create_NWN_from_txt(\n    filename: str,\n    conductance: float = 1.0,\n    diameter: float = 1.0,\n    resistivity: float = 1.0,\n    units: Dict[str, float] = None,\n) -&gt; NanowireNetwork\n</code></pre> <p>Create a nanowire network represented by a NetworkX graph. Wires are represented by the graph's vertices, while the wire junctions are represented by the graph's edges.</p> <p>The text file input is assumed to be in two columns: x and y. Each wire is a pair of rows, one row containing the start point and the following containing the end point. The first two pairs of rows are the electrodes.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Text file containing the start and end locations of the wires.</p> required <code>conductance</code> <code>float</code> <p>The junction conductance of the nanowires where they intersect. Given in units of (Ron)^-1.</p> <code>1.0</code> <code>diameter</code> <code>float</code> <p>The diameter of each nanowire. Given in units of D0.</p> <code>1.0</code> <code>resistivity</code> <code>float</code> <p>The resistivity of each nanowire. Given in units of rho0.</p> <code>1.0</code> <code>units</code> <code>dict</code> <p>Dictionary of custom base units. Defaults to None which will use the default units given in <code>units.py</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>NWN</code> <code>Graph</code> <p>The created random nanowire network.</p> Source code in <code>mnns/fromtext.py</code> <pre><code>def create_NWN_from_txt(\n    filename: str,\n    conductance: float = 1.0,\n    diameter: float = 1.0,\n    resistivity: float = 1.0,\n    units: Dict[str, float] = None,\n) -&gt; NanowireNetwork:\n    \"\"\"\n    Create a nanowire network represented by a NetworkX graph. Wires are\n    represented by the graph's vertices, while the wire junctions are\n    represented by the graph's edges.\n\n    The text file input is assumed to be in two columns: x and y.\n    Each wire is a pair of rows, one row containing the start point and the\n    following containing the end point. The first two pairs of rows are the\n    electrodes.\n\n    Parameters\n    ----------\n    filename : str\n        Text file containing the start and end locations of the wires.\n\n    conductance : float, optional\n        The junction conductance of the nanowires where they intersect.\n        Given in units of (Ron)^-1.\n\n    diameter : float, optional\n        The diameter of each nanowire. Given in units of D0.\n\n    resistivity : float, optional\n        The resistivity of each nanowire. Given in units of rho0.\n\n    units : dict, optional\n        Dictionary of custom base units. Defaults to None which will use the\n        default units given in `units.py`\n\n    Returns\n    -------\n    NWN : Graph\n        The created random nanowire network.\n\n    \"\"\"\n    # Get coordinates from text file\n    x, y = np.loadtxt(filename, unpack=True)\n\n    # Convert to LineStrings\n    line_list = []\n    for i in range(0, len(x), 2):\n        line_list.append(LineString([(x[i], y[i]), (x[i + 1], y[i + 1])]))\n\n    # Find dimensions\n    length = np.max(x) - np.min(x)\n    width = np.max(y) - np.min(y)\n    shape = (length, width)\n    area = length * width\n\n    # Get characteristic units\n    units = NWNUnits(units)\n\n    # Create NWN graph\n    NWN = NanowireNetwork(\n        wire_length=None,\n        length=length,\n        width=width,\n        shape=shape,\n        wire_density=0,\n        wire_num=0,\n        junction_conductance=conductance,\n        junction_capacitance=None,\n        wire_diameter=diameter,\n        wire_resistivity=resistivity,\n        electrode_list=[],\n        lines=[],\n        type=\"JDA\",\n        units=units,\n        loc={},\n        node_indices={},\n    )\n\n    # Split lines\n    electrode_lines = line_list[0:2]\n    wire_lines = line_list[2:]\n\n    # Add wires to the graph\n    add_wires(NWN, electrode_lines, [True] * len(electrode_lines))\n    add_wires(NWN, wire_lines, [False] * len(wire_lines))\n\n    # Find junction density\n    NWN.graph[\"junction_density\"] = len(NWN.graph[\"loc\"].keys()) / area\n\n    return NWN\n</code></pre>"},{"location":"reference/mnns/line_functions/","title":"mnns.line_functions","text":""},{"location":"reference/mnns/line_functions/#mnns.line_functions","title":"mnns.line_functions","text":"<p>Functions for random lines.</p> <p>Functions:</p> Name Description <code>add_points_to_line</code> <p>Given a list of points and a line, add the projected points to the line.</p> <code>create_line</code> <p>Generate random lines with random orientations with midpoints ranging from</p> <code>find_intersects</code> <p>Given a list of LineStrings, finds all the lines that intersect and where.</p> <code>find_line_intersects</code> <p>Given a list of LineStrings, find all the lines that intersect</p>"},{"location":"reference/mnns/line_functions/#mnns.line_functions.add_points_to_line","title":"add_points_to_line","text":"<pre><code>add_points_to_line(\n    line: LineString,\n    points: list[Point],\n    return_ordering=False,\n)\n</code></pre> <p>Given a list of points and a line, add the projected points to the line.</p> <p>See general form at: https://stackoverflow.com/questions/34754777/shapely-split-linestrings-at-intersections-with-other-linestrings</p> Source code in <code>mnns/line_functions.py</code> <pre><code>def add_points_to_line(\n    line: LineString, points: list[Point], return_ordering=False\n):\n    \"\"\"\n    Given a list of points and a line, add the projected points to the line.\n\n    See general form at:\n    https://stackoverflow.com/questions/34754777/shapely-split-linestrings-at-intersections-with-other-linestrings\n\n    \"\"\"\n    # First coords of line (start + end)\n    coords = [line.coords[0], line.coords[-1]]\n\n    # Add the coords from the points\n    coords += [(p.x, p.y) for p in points]\n\n    # Calculate the distance along the line for each point\n    dists = [line.project(Point(p)) for p in coords]\n\n    # Sort the coords based on the distances\n    coords, ordering = map(\n        list,\n        zip(\n            *[\n                (point, ind)\n                for _, point, ind in sorted(\n                    zip(dists, coords, range(len(coords)))\n                )\n            ]\n        ),\n    )\n\n    ordering.remove(0)\n    ordering.remove(1)\n    ordering = [ordering[i] - 2 for i in range(len(ordering))]\n\n    # Overwrite old line\n    line = LineString(coords)\n\n    if return_ordering:\n        return line, ordering\n    else:\n        return line\n</code></pre>"},{"location":"reference/mnns/line_functions/#mnns.line_functions.create_line","title":"create_line","text":"<pre><code>create_line(\n    length: float = 1,\n    xmin: float = 0,\n    xmax: float = 1,\n    ymin: float = 0,\n    ymax: float = 1,\n    rng: Generator | None = None,\n    angle_dist: str = \"uniform\",\n    angle_kwargs: dict | None = None,\n) -&gt; LineString\n</code></pre> <p>Generate random lines with random orientations with midpoints ranging from area from <code>xmin</code> to <code>xmax</code> and from <code>ymin</code> to <code>ymax</code>.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Length of line</p> <code>1</code> <code>xmin</code> <code>float</code> <p>Minimum x coordinate midpoint.</p> <code>0</code> <code>xmax</code> <code>float</code> <p>Minimum x coordinate midpoint.</p> <code>1</code> <code>ymin</code> <code>float</code> <p>Minimum y coordinate midpoint.</p> <code>0</code> <code>ymax</code> <code>float</code> <p>Minimum y coordinate midpoint.</p> <code>1</code> <code>rng</code> <code>Generator</code> <p>Generator object usually created from <code>default_rng</code> from <code>numpy.random</code>. A seeded generator can be passed for consistent random numbers. If None, uses the default NumPy random functions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>out</code> <code>LineString</code> <p>LineString of the generated line.</p> Source code in <code>mnns/line_functions.py</code> <pre><code>def create_line(\n    length: float = 1,\n    xmin: float = 0,\n    xmax: float = 1,\n    ymin: float = 0,\n    ymax: float = 1,\n    rng: np.random.Generator | None = None,\n    angle_dist: str = \"uniform\",\n    angle_kwargs: dict | None = None,\n) -&gt; LineString:\n    \"\"\"\n    Generate random lines with random orientations with midpoints ranging from\n    area from ``xmin`` to ``xmax`` and from ``ymin`` to ``ymax``.\n\n    Parameters\n    ----------\n    length : float\n        Length of line\n\n    xmin : float\n        Minimum x coordinate midpoint.\n\n    xmax : float\n        Minimum x coordinate midpoint.\n\n    ymin : float\n        Minimum y coordinate midpoint.\n\n    ymax : float\n        Minimum y coordinate midpoint.\n\n    rng : Generator\n        Generator object usually created from ``default_rng`` from\n        ``numpy.random``. A seeded generator can be passed for consistent\n        random numbers. If None, uses the default NumPy random functions.\n\n    Returns\n    -------\n    out : LineString\n        LineString of the generated line.\n\n    \"\"\"\n    # Set default arguments\n    if rng is None:\n        rng = np.random.default_rng()\n\n    if angle_kwargs is None:\n        angle_kwargs = dict()\n\n    if angle_dist == \"uniform\" and not angle_kwargs:\n        angle_kwargs = {\"low\": 0, \"high\": np.pi}\n\n    # Get angle distribution\n    try:\n        dist = getattr(rng, angle_dist)\n    except AttributeError as e:\n        raise ValueError(\n            \"Distribution not found in 'numpy.random.Generator'\"\n        ) from e\n\n    # Randomly generate midpoints\n    xmid = rng.uniform(xmin, xmax)\n    ymid = rng.uniform(ymin, ymax)\n\n    # Randomly generate angle\n    angle = dist(**angle_kwargs)\n\n    # Create the line string object\n    xhalf = length / 2 * np.cos(angle)\n    yhalf = length / 2 * np.sin(angle)\n\n    xstart, xend = xmid - xhalf, xmid + xhalf\n    ystart, yend = ymid - yhalf, ymid + yhalf\n\n    out = LineString([(xstart, ystart), (xend, yend)])\n    return out\n</code></pre>"},{"location":"reference/mnns/line_functions/#mnns.line_functions.find_intersects","title":"find_intersects","text":"<pre><code>find_intersects(\n    lines: list,\n) -&gt; dict[tuple[int, int], Point]\n</code></pre> <p>Given a list of LineStrings, finds all the lines that intersect and where.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list of LineStrings</code> <p>List of the LineStrings to find the intersections of.</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict</code> <p>Dictionary where the key is a tuple of the pair of intersecting lines and the value is the intersection locations.</p> Source code in <code>mnns/line_functions.py</code> <pre><code>def find_intersects(lines: list) -&gt; dict[tuple[int, int], Point]:\n    \"\"\"\n    Given a list of LineStrings, finds all the lines that intersect and where.\n\n    Parameters\n    ----------\n    lines : list of LineStrings\n        List of the LineStrings to find the intersections of.\n\n    Returns\n    -------\n    out : dict\n        Dictionary where the key is a tuple of the pair of intersecting lines\n        and the value is the intersection locations.\n\n    \"\"\"\n    out = {}\n\n    for i, j in zip(*np.triu_indices(n=len(lines), k=1)):\n        # Check for intersection first before calculating it\n        if lines[i].intersects(lines[j]):\n            out.update({(i, j): lines[i].intersection(lines[j])})\n\n    return out\n</code></pre>"},{"location":"reference/mnns/line_functions/#mnns.line_functions.find_line_intersects","title":"find_line_intersects","text":"<pre><code>find_line_intersects(\n    ind: int, lines: list[LineString]\n) -&gt; dict[tuple[int, int], Point]\n</code></pre> <p>Given a list of LineStrings, find all the lines that intersect with a specified line in the list given by the index <code>ind</code>.</p> Source code in <code>mnns/line_functions.py</code> <pre><code>def find_line_intersects(\n    ind: int, lines: list[LineString]\n) -&gt; dict[tuple[int, int], Point]:\n    \"\"\"\n    Given a list of LineStrings, find all the lines that intersect\n    with a specified line in the list given by the index ``ind``.\n\n    \"\"\"\n    out = {}\n\n    for j in range(len(lines)):\n        # Skip intersection with the line itself\n        if ind == j:\n            continue\n\n        # Checking if these's an intersection first is faster\n        if lines[ind].intersects(lines[j]):\n            if ind &lt; j:\n                out.update({(ind, j): lines[ind].intersection(lines[j])})\n            else:\n                out.update({(j, ind): lines[ind].intersection(lines[j])})\n\n    return out\n</code></pre>"},{"location":"reference/mnns/models/","title":"mnns.models","text":""},{"location":"reference/mnns/models/#mnns.models","title":"mnns.models","text":"<p>Various dynamic models for nanowire networks.</p> <p>Functions:</p> Name Description <code>HP_model</code> <p>HP Model [1]. Provides the time derivative of the state variable <code>x</code> (the</p> <code>SLT_HP_model</code> <p>SLT HP Model [1]. Provides the time derivative of the state variable <code>x</code></p> <code>decay_HP_model</code> <p>Decay HP Model [1]. Provides the time derivative of the state variable <code>x</code></p> <code>resist_func</code> <p>Linear resistance function in nondimensionalized form.</p>"},{"location":"reference/mnns/models/#mnns.models.HP_model","title":"HP_model","text":"<pre><code>HP_model(\n    t: float,\n    x: NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: Optional[dict] = None,\n) -&gt; npt.NDArray\n</code></pre> <p>HP Model [1]. Provides the time derivative of the state variable <code>x</code> (the dimensionless version of <code>w</code>). Assumes voltage sources are used.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time to solve at.</p> required <code>x</code> <code>ndarray</code> <p>Array containing the state variable <code>x</code> for each junction in the NWN.</p> required <code>NWN</code> <code>NanowireNetwork</code> <p>Input nanowire network graph.</p> required <code>source_node</code> <code>NWNNode or list of NWNNode</code> <p>Source node(s) of the input voltage.</p> required <code>drain_node</code> <code>NWNNode or list of NWNNode</code> <p>Drain/grounded node(s).</p> required <code>voltage_func</code> <code>Callable</code> <p>Function which inputs the time as a scalar and returns the voltage of all the source nodes as a scalar.</p> required <code>window_func</code> <code>Callable</code> <p>Function which inputs the state variable <code>x</code> as an array and returns the window function value as an array.</p> required <code>solver</code> <code>str</code> <p>SciPy sparse matrix equation solver.</p> <code>'spsolve'</code> <code>**kwargs</code> <code>Optional[dict]</code> <p>Keyword arguments to pass to the SciPy sparse matrix equation solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dxdt</code> <code>ndarray</code> <p>Array of the time derivative of the state variable <code>x</code>.</p> References <p>[1] D. B. Strukov, G. S. Snider, D. R. Stewart and R. S. Williams,     Nature, 2008, 453, 80-83</p> Source code in <code>mnns/models.py</code> <pre><code>def HP_model(\n    t: float,\n    x: npt.NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: Optional[dict] = None,\n) -&gt; npt.NDArray:\n    \"\"\"\n    HP Model [1]. Provides the time derivative of the state variable `x` (the\n    dimensionless version of `w`). Assumes voltage sources are used.\n\n    Parameters\n    ----------\n    t : float\n        Current time to solve at.\n\n    x : ndarray\n        Array containing the state variable `x` for each junction in the NWN.\n\n    NWN : NanowireNetwork\n        Input nanowire network graph.\n\n    source_node : NWNNode or list of NWNNode\n        Source node(s) of the input voltage.\n\n    drain_node : NWNNode or list of NWNNode\n        Drain/grounded node(s).\n\n    voltage_func : Callable\n        Function which inputs the time as a scalar and returns the voltage of\n        all the source nodes as a scalar.\n\n    window_func : Callable\n        Function which inputs the state variable `x` as an array and returns\n        the window function value as an array.\n\n    solver : str\n        SciPy sparse matrix equation solver.\n\n    **kwargs\n        Keyword arguments to pass to the SciPy sparse matrix equation solver.\n\n    Returns\n    -------\n    dxdt : ndarray\n        Array of the time derivative of the state variable `x`.\n\n    References\n    ----------\n    [1] D. B. Strukov, G. S. Snider, D. R. Stewart and R. S. Williams,\n        *Nature*, 2008, **453**, 80-83\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = dict()\n\n    # Update all wire junction resistances\n    R = NWN.update_resistance(x)\n\n    # Find applied voltage at the current time\n    applied_V = voltage_func(t)\n\n    # Solve for voltage at each node\n    *V, I = solve_network(\n        NWN, source_node, drain_node, applied_V, \"voltage\", solver, **kwargs\n    )\n    V = np.asarray(V)\n\n    # Get start and end indices\n    start, end = NWN.wire_junction_indices()\n\n    # Find voltage differences\n    v0 = V[start]\n    v1 = V[end]\n    V_delta = np.abs(v0 - v1) * np.sign(applied_V)\n\n    # Find dw/dt\n    dxdt = V_delta / R * window_func(x)\n\n    return dxdt\n</code></pre>"},{"location":"reference/mnns/models/#mnns.models.SLT_HP_model","title":"SLT_HP_model","text":"<pre><code>SLT_HP_model(\n    t: float,\n    y: NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: Optional[dict] = None,\n) -&gt; npt.NDArray\n</code></pre> <p>SLT HP Model [1]. Provides the time derivative of the state variable <code>x</code> (the dimensionless version of <code>w</code>), <code>tau</code>, and <code>epsilon</code>. Assumes that these state variable are concatenated into a single 1D array input.</p> <p>Assumes voltage sources are used.</p> <p>Requires <code>NWN.graph[\"tau\"]</code> to be set to the decay constant value.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time to solve at.</p> required <code>y</code> <code>ndarray</code> <p>Array containing the state variables <code>x</code>, <code>tau</code>, and <code>epsilon</code> for each junction in the NWN concatenated into a single 1D array input.</p> required <code>NWN</code> <code>NanowireNetwork</code> <p>Input nanowire network graph.</p> required <code>source_node</code> <code>NWNNode or list of NWNNode</code> <p>Source node(s) of the input voltage.</p> required <code>drain_node</code> <code>NWNNode or list of NWNNode</code> <p>Drain/grounded node(s).</p> required <code>voltage_func</code> <code>Callable</code> <p>Function which inputs the time as a scalar and returns the voltage of all the source nodes as a scalar.</p> required <code>window_func</code> <code>Callable</code> <p>Function which inputs the state variable <code>x</code> as an array and returns the window function value as an array.</p> required <code>solver</code> <code>str</code> <p>SciPy sparse matrix equation solver.</p> <code>'spsolve'</code> <code>**kwargs</code> <code>Optional[dict]</code> <p>Keyword arguments to pass to the SciPy sparse matrix equation solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dydt</code> <code>ndarray</code> <p>Array of the time derivative of the state variables <code>x</code>, <code>tau</code>, and <code>epsilon</code>, concatenated into a 1D array.</p> References <p>[1] L. Chen, C. Li, T. Huang, H. G. Ahmad and Y. Chen, Physics Letters A,     2014, 378, 2924-2930</p> Source code in <code>mnns/models.py</code> <pre><code>def SLT_HP_model(\n    t: float,\n    y: npt.NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: Optional[dict] = None,\n) -&gt; npt.NDArray:\n    \"\"\"\n    SLT HP Model [1]. Provides the time derivative of the state variable `x`\n    (the dimensionless version of `w`), `tau`, and `epsilon`. Assumes that\n    these state variable are concatenated into a single 1D array input.\n\n    Assumes voltage sources are used.\n\n    Requires `NWN.graph[\"tau\"]` to be set to the decay constant value.\n\n    Parameters\n    ----------\n    t : float\n        Current time to solve at.\n\n    y : ndarray\n        Array containing the state variables `x`, `tau`, and `epsilon` for each\n        junction in the NWN concatenated into a single 1D array input.\n\n    NWN : NanowireNetwork\n        Input nanowire network graph.\n\n    source_node : NWNNode or list of NWNNode\n        Source node(s) of the input voltage.\n\n    drain_node : NWNNode or list of NWNNode\n        Drain/grounded node(s).\n\n    voltage_func : Callable\n        Function which inputs the time as a scalar and returns the voltage of\n        all the source nodes as a scalar.\n\n    window_func : Callable\n        Function which inputs the state variable `x` as an array and returns\n        the window function value as an array.\n\n    solver : str\n        SciPy sparse matrix equation solver.\n\n    **kwargs\n        Keyword arguments to pass to the SciPy sparse matrix equation solver.\n\n    Returns\n    -------\n    dydt : ndarray\n        Array of the time derivative of the state variables `x`, `tau`, and\n        `epsilon`, concatenated into a 1D array.\n\n    References\n    ----------\n    [1] L. Chen, C. Li, T. Huang, H. G. Ahmad and Y. Chen, *Physics Letters A*,\n        2014, **378**, 2924-2930\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = dict()\n\n    # Unpack values\n    w, tau, epsilon = np.split(y, 3)\n    sigma, theta, a = NWN.graph[\"sigma\"], NWN.graph[\"theta\"], NWN.graph[\"a\"]\n\n    # Update all wire junction resistances\n    R = NWN.update_resistance(w)\n\n    # Find applied voltage at the current time\n    applied_V = voltage_func(t)\n\n    # Solve for voltage at each node\n    *V, I = solve_network(\n        NWN, source_node, drain_node, applied_V, \"voltage\", solver, **kwargs\n    )\n    V = np.asarray(V)\n\n    # Get start and end indices\n    start, end = NWN.wire_junction_indices()\n\n    # Find voltage differences\n    v0 = V[start]\n    v1 = V[end]\n    V_delta = np.abs(v0 - v1) * np.sign(applied_V)\n\n    # Find derivatives\n    l = V_delta / R\n    dw_dt = (l - ((w - epsilon) / tau)) * window_func(w)\n    dtau_dt = theta * l * (a - w)\n    deps_dt = sigma * l * window_func(w)\n    dydt = np.hstack((dw_dt, dtau_dt, deps_dt))\n\n    return dydt\n</code></pre>"},{"location":"reference/mnns/models/#mnns.models.decay_HP_model","title":"decay_HP_model","text":"<pre><code>decay_HP_model(\n    t: float,\n    x: NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: dict = None,\n) -&gt; npt.NDArray\n</code></pre> <p>Decay HP Model [1]. Provides the time derivative of the state variable <code>x</code> (the dimensionless version of <code>w</code>). Assumes voltage sources are used.</p> <p>Requires <code>NWN.graph[\"tau\"]</code> to be set to the decay constant value.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time to solve at.</p> required <code>x</code> <code>ndarray</code> <p>Array containing the state variable <code>x</code> for each junction in the NWN.</p> required <code>NWN</code> <code>NanowireNetwork</code> <p>Input nanowire network graph.</p> required <code>source_node</code> <code>NWNNode or list of NWNNode</code> <p>Source node(s) of the input voltage.</p> required <code>drain_node</code> <code>NWNNode or list of NWNNode</code> <p>Drain/grounded node(s).</p> required <code>voltage_func</code> <code>Callable</code> <p>Function which inputs the time as a scalar and returns the voltage of all the source nodes as a scalar.</p> required <code>window_func</code> <code>Callable</code> <p>Function which inputs the state variable <code>x</code> as an array and returns the window function value as an array.</p> required <code>solver</code> <code>str</code> <p>SciPy sparse matrix equation solver.</p> <code>'spsolve'</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the SciPy sparse matrix equation solver.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dxdt</code> <code>ndarray</code> <p>Array of the time derivative of the state variable <code>x</code>.</p> References <p>[1] H. O. Sillin, R. Aguilera, H.-H. Shieh, A. V. Avizienis, M. Aono,     A. Z. Stieg and J. K. Gimzewski, Nanotechnology, 2013, 24, 384004.</p> Source code in <code>mnns/models.py</code> <pre><code>def decay_HP_model(\n    t: float,\n    x: npt.NDArray,\n    NWN: NanowireNetwork,\n    source_node: NWNNode | list[NWNNode],\n    drain_node: NWNNode | list[NWNNode],\n    voltage_func: Callable,\n    window_func: Callable,\n    solver: str = \"spsolve\",\n    kwargs: dict = None,\n) -&gt; npt.NDArray:\n    \"\"\"\n    Decay HP Model [1]. Provides the time derivative of the state variable `x`\n    (the dimensionless version of `w`). Assumes voltage sources are used.\n\n    Requires `NWN.graph[\"tau\"]` to be set to the decay constant value.\n\n    Parameters\n    ----------\n    t : float\n        Current time to solve at.\n\n    x : ndarray\n        Array containing the state variable `x` for each junction in the NWN.\n\n    NWN : NanowireNetwork\n        Input nanowire network graph.\n\n    source_node : NWNNode or list of NWNNode\n        Source node(s) of the input voltage.\n\n    drain_node : NWNNode or list of NWNNode\n        Drain/grounded node(s).\n\n    voltage_func : Callable\n        Function which inputs the time as a scalar and returns the voltage of\n        all the source nodes as a scalar.\n\n    window_func : Callable\n        Function which inputs the state variable `x` as an array and returns\n        the window function value as an array.\n\n    solver : str\n        SciPy sparse matrix equation solver.\n\n    **kwargs\n        Keyword arguments to pass to the SciPy sparse matrix equation solver.\n\n    Returns\n    -------\n    dxdt : ndarray\n        Array of the time derivative of the state variable `x`.\n\n    References\n    ----------\n    [1] H. O. Sillin, R. Aguilera, H.-H. Shieh, A. V. Avizienis, M. Aono,\n        A. Z. Stieg and J. K. Gimzewski, *Nanotechnology*, 2013, **24**, 384004.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = dict()\n\n    # Update all wire junction resistances\n    R = NWN.update_resistance(x)\n\n    # Find applied voltage at the current time\n    applied_V = voltage_func(t)\n\n    # Solve for voltage at each node\n    *V, I = solve_network(\n        NWN, source_node, drain_node, applied_V, \"voltage\", solver, **kwargs\n    )\n    V = np.array(V)\n\n    # Get start and end indices\n    start, end = NWN.wire_junction_indices()\n\n    # Find voltage differences\n    v0 = V[start]\n    v1 = V[end]\n    V_delta = np.abs(v0 - v1) * np.sign(applied_V)\n\n    # Get decay constant\n    tau = NWN.graph[\"tau\"]\n\n    # Find dw/dt\n    dxdt = (V_delta / R * window_func(x)) - (x / tau)\n\n    return dxdt\n</code></pre>"},{"location":"reference/mnns/models/#mnns.models.resist_func","title":"resist_func","text":"<pre><code>resist_func(\n    NWN: NanowireNetwork, w: float | NDArray\n) -&gt; float | npt.NDArray\n</code></pre> <p>Linear resistance function in nondimensionalized form.</p> <p>Obtained from Strukov et al. Nature, 2008, 453, 80-83.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>NanowireNetwork</code> <p>Nanowire network.</p> required <code>w</code> <code>ndarray or scalar</code> <p>Nondimensionalized state variable of the memristor element(s).</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>ndarray or scalar</code> <p>Resistance of the memristor element(s).</p> Source code in <code>mnns/models.py</code> <pre><code>def resist_func(\n    NWN: NanowireNetwork, w: float | npt.NDArray\n) -&gt; float | npt.NDArray:\n    \"\"\"\n    Linear resistance function in nondimensionalized form.\n\n    Obtained from Strukov et al. *Nature*, 2008, **453**, 80-83.\n\n    Parameters\n    ----------\n    NWN : NanowireNetwork\n        Nanowire network.\n\n    w : ndarray or scalar\n        Nondimensionalized state variable of the memristor element(s).\n\n    Returns\n    -------\n    R : ndarray or scalar\n        Resistance of the memristor element(s).\n\n    \"\"\"\n    Roff_Ron = NWN.graph[\"units\"][\"Roff_Ron\"]\n    R = w * (1 - Roff_Ron) + Roff_Ron\n    return R\n</code></pre>"},{"location":"reference/mnns/nanowire_network/","title":"mnns.nanowire_network","text":""},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network","title":"mnns.nanowire_network","text":"<p>Functions to create nanowire networks.</p> <p>Classes:</p> Name Description <code>NanowireNetwork</code> <p>Internal nanowire network object. Should not be instantiated directly.</p> <code>ParameterNotSetError</code> <p>Raised when an parameter that needs to used has not been set yet.</p> <p>Functions:</p> Name Description <code>create_NWN</code> <p>Create a nanowire network represented by a NetworkX graph. Wires are</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork","title":"NanowireNetwork","text":"<pre><code>NanowireNetwork(incoming_graph_data=None, **attr)\n</code></pre> <p>               Bases: <code>Graph</code></p> <p>Internal nanowire network object. Should not be instantiated directly. Use <code>mnns.create_NWN</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_graph_data</code> <code>input graph</code> <p>Data to initialize graph. Same as networkx.Graph object.</p> <code>None</code> <code>**attr</code> <p>Keyword arguments. Same as networkx.Graph object.</p> <code>{}</code> <p>Methods:</p> Name Description <code>evolve</code> <p>Evolve the nanowire network using the given model and state variables.</p> <code>get_index</code> <p>Return the unique index of a node in the network.</p> <code>get_index_from_edge</code> <p>Return the indices of the nodes in the edge as a tuple.</p> <code>get_node</code> <p>Return the node corresponding to the index.</p> <code>get_state_var</code> <p>Get the state variable of the memristors (nanowire network wire</p> <code>set_state_var</code> <p>Set the state variable of the memristors (nanowire network wire</p> <code>to_MNR</code> <p>Converts the NWN to the multi-nodal representation (MNR).</p> <code>update_resistance</code> <p>Update the resistance of the nanowire network based on the provided</p> <code>wire_junction_indices</code> <p>Return the start and end indices of the wire junctions in the network</p> <p>Attributes:</p> Name Type Description <code>lines</code> <code>list[LineString]</code> <p>List of LineStrings representing the nanowires. Includes electrodes.</p> <code>loc</code> <code>dict[tuple[int, int], Point]</code> <p>Dictionary of graph edge locations (nanowire junctions). Only</p> <code>n_wires</code> <code>int</code> <p>Number of wires in the network. Does not include electrodes.</p> <code>resistance_function</code> <code>Callable[[NanowireNetwork, ArrayLike], ArrayLike]</code> <p>Resistance function of the nanowire network. Should have the calling</p> <code>wire_density</code> <code>float</code> <p>Wire density in units of (l0)^-2. Does not include electrodes.</p> <code>wire_junctions</code> <code>list[NWNEdge]</code> <p>Return a list of edges with the \"type\" attribute set to \"junction\".</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def __init__(self, incoming_graph_data=None, **attr):\n    super().__init__(incoming_graph_data, **attr)\n    self._resist_func = None\n    self._state_vars: list[str] = []\n    self._state_vars_is_set: list[bool] = []\n    self._wire_junctions = None\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[LineString]\n</code></pre> <p>List of LineStrings representing the nanowires. Includes electrodes.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.loc","title":"loc  <code>property</code>","text":"<pre><code>loc: dict[tuple[int, int], Point]\n</code></pre> <p>Dictionary of graph edge locations (nanowire junctions). Only represents anything meaningful for JDA NWNs. MNR NWNs do not update this value. Indexes with a NWNEdge but without the nested tuples.</p> <p>Does not have a guaranteed ordering.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.n_wires","title":"n_wires  <code>property</code>","text":"<pre><code>n_wires: int\n</code></pre> <p>Number of wires in the network. Does not include electrodes.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.resistance_function","title":"resistance_function  <code>property</code> <code>writable</code>","text":"<pre><code>resistance_function: Callable[\n    [NanowireNetwork, ArrayLike], ArrayLike\n]\n</code></pre> <p>Resistance function of the nanowire network. Should have the calling signature <code>func(NWN, param1, [param2, ...])</code> where <code>NWN</code> is the nanowire network, and <code>param1</code>, <code>param2</code>, etc. are the state variables of the memristor element(s).</p> <p>You can also pass the string \"linear\" to choose a default linear resistance function based on the state variable x in [0, 1].</p> <p>The resistance should be nondimensionalized, i.e. the resistance should be in units of Ron.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.wire_density","title":"wire_density  <code>property</code>","text":"<pre><code>wire_density: float\n</code></pre> <p>Wire density in units of (l0)^-2. Does not include electrodes.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.wire_junctions","title":"wire_junctions  <code>deletable</code> <code>property</code>","text":"<pre><code>wire_junctions: list[NWNEdge]\n</code></pre> <p>Return a list of edges with the \"type\" attribute set to \"junction\". Once called, the list is cached so the ordering can be fixed. If wires are added, clear the cache by deleting the property.</p>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.evolve","title":"evolve","text":"<pre><code>evolve(\n    model: Callable[..., ArrayLike],\n    t_eval: NDArray,\n    args: tuple[Any, ...] = (),\n    state_vars: Optional[list[str]] = None,\n    ivp_options: dict = {},\n) -&gt; OdeResult\n</code></pre> <p>Evolve the nanowire network using the given model and state variables. Returns the solution of the initial value problem solver from scipy at the given time points.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>callable</code> <p>Model to use for the evolution. Should be a function with the signature <code>func(t, y, *args)</code> where <code>t</code> is the time, <code>y</code> is the state variable(s), and <code>args</code> are any additional arguments. Pre-implemented models include: <code>mnns.models.HP_model</code>, <code>mnns.models.decay_HP_model</code>, and <code>mnns.models.SLT_HP_model</code>.</p> required <code>t_eval</code> <code>ndarray</code> <p>Time points to evaluate the solution at.</p> required <code>state_vars</code> <code>list of str</code> <p>List of state variables to evolve. If not provided, all state variables in <code>self.state_vars</code> will be used.</p> <code>None</code> <code>args</code> <code>tuple</code> <p>Additional arguments to pass to the model function. Most likely, you will need to provide args for the source node(s), drain node(s) and voltage function.</p> <code>()</code> <code>ivp_options</code> <code>dict</code> <p>Additional keyword arguments to pass to the IVP solver.</p> <code>{}</code> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def evolve(\n    self,\n    model: Callable[..., npt.ArrayLike],\n    t_eval: npt.NDArray,\n    args: tuple[Any, ...] = (),\n    state_vars: Optional[list[str]] = None,\n    ivp_options: dict = {},\n) -&gt; OdeResult:\n    \"\"\"\n    Evolve the nanowire network using the given model and state variables.\n    Returns the solution of the initial value problem solver from scipy\n    at the given time points.\n\n    Parameters\n    ----------\n    model : callable\n        Model to use for the evolution. Should be a function with the\n        signature `func(t, y, *args)` where `t` is the time, `y` is the\n        state variable(s), and `args` are any additional arguments.\n        Pre-implemented models include:\n        [`mnns.models.HP_model`](models.md#mnns.models.HP_model),\n        [`mnns.models.decay_HP_model`](models.md#mnns.models.decay_HP_model),\n        and [`mnns.models.SLT_HP_model`](models.md#mnns.models.SLT_HP_model).\n\n    t_eval : ndarray\n        Time points to evaluate the solution at.\n\n    state_vars : list of str, optional\n        List of state variables to evolve. If not provided, all\n        state variables in `self.state_vars` will be used.\n\n    args : tuple, optional\n        Additional arguments to pass to the model function. Most likely,\n        you will need to provide args for the source node(s), drain node(s)\n        and voltage function.\n\n    ivp_options : dict, optional\n        Additional keyword arguments to pass to the IVP solver.\n\n    \"\"\"\n    if state_vars is None:\n        state_vars = self.state_vars\n\n    # Check if state variables are set\n    if not all([self._state_vars_is_set[var] for var in state_vars]):\n        raise ParameterNotSetError(\n            \"Not all state variables have not been set yet.\"\n        )\n\n    # Get initial state variable, if there are more than one, they\n    # will be concatenated.\n    y0 = np.hstack([self.get_state_var(var) for var in state_vars])\n\n    # Set the tolerance value for the IVP solver\n    if \"atol\" not in ivp_options.keys():\n        ivp_options[\"atol\"] = 1e-7\n    if \"rtol\" not in ivp_options.keys():\n        ivp_options[\"rtol\"] = 1e-7\n\n    t_span = (t_eval[0], t_eval[-1])\n\n    # Solve how the state variables change over time\n    sol = solve_ivp(\n        model, t_span, y0, \"DOP853\", t_eval, args=args, **ivp_options\n    )\n\n    # Update the state variables\n    split = np.split(sol.y[:, -1], len(state_vars))\n    for var, new_vals in zip(state_vars, split):\n        self.set_state_var(var, new_vals)\n\n    return sol\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.get_index","title":"get_index","text":"<pre><code>get_index(node: NWNNode | list[NWNNode]) -&gt; NWNNodeIndex\n</code></pre> <p>Return the unique index of a node in the network.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def get_index(self, node: NWNNode | list[NWNNode]) -&gt; NWNNodeIndex:\n    \"\"\"Return the unique index of a node in the network.\"\"\"\n    return self.graph[\"node_indices\"][node]\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.get_index_from_edge","title":"get_index_from_edge","text":"<pre><code>get_index_from_edge(\n    edge: NWNEdge | list[NWNEdge],\n) -&gt; NWNEdgeIndex | list[NWNEdgeIndex]\n</code></pre> <p>Return the indices of the nodes in the edge as a tuple.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def get_index_from_edge(\n    self, edge: NWNEdge | list[NWNEdge]\n) -&gt; NWNEdgeIndex | list[NWNEdgeIndex]:\n    \"\"\"Return the indices of the nodes in the edge as a tuple.\"\"\"\n    if isinstance(edge, list):\n        return [tuple(map(self.get_index, e)) for e in edge]\n    else:\n        return tuple(map(self.get_index, edge))\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.get_node","title":"get_node","text":"<pre><code>get_node(index: NWNNodeIndex) -&gt; NWNNode\n</code></pre> <p>Return the node corresponding to the index.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def get_node(self, index: NWNNodeIndex) -&gt; NWNNode:\n    \"\"\"Return the node corresponding to the index.\"\"\"\n    try:\n        return next(\n            k for k, v in self.graph[\"node_indices\"].items() if v == index\n        )\n    except StopIteration as e:\n        raise ValueError(\"given index does not have a node\") from e\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.get_state_var","title":"get_state_var","text":"<pre><code>get_state_var(\n    var_name: str, edge_list: list[NWNEdge] | None = None\n) -&gt; npt.ArrayLike\n</code></pre> <p>Get the state variable of the memristors (nanowire network wire junctions) in the network.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the state variable(s) to get.</p> required <code>edge_list</code> <code>list of edges</code> <p>List of edges to get the state variable from. If None, all wire junction edges will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray or scalar</code> <p>Value of the state variable(s).</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def get_state_var(\n    self, var_name: str, edge_list: list[NWNEdge] | None = None\n) -&gt; npt.ArrayLike:\n    \"\"\"\n    Get the state variable of the memristors (nanowire network wire\n    junctions) in the network.\n\n    Parameters\n    ----------\n    var_name : str\n        Name of the state variable(s) to get.\n\n    edge_list : list of edges, optional\n        List of edges to get the state variable from. If None, all wire\n        junction edges will be used.\n\n    Returns\n    -------\n    ndarray or scalar\n        Value of the state variable(s).\n\n    \"\"\"\n    if var_name not in self.state_vars:\n        cls = self.__class__\n        raise AttributeError(\n            f\"'{var_name}' is not in {cls.__qualname__}.state_vars (currently is {self.state_vars}).\"\n            f\"\\nDid you set it using {cls.__qualname__}.state_vars = ['{var_name}', ...]?\"\n        )\n\n    if edge_list is None:\n        edge_list = self.wire_junctions\n\n    try:\n        return np.array(\n            [self[edge[0]][edge[1]][var_name] for edge in edge_list]\n        )\n    except KeyError as e:\n        raise ParameterNotSetError(\n            f\"'{var_name}' has not been set yet using `set_state_var`.\"\n        ) from e\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.set_state_var","title":"set_state_var","text":"<pre><code>set_state_var(\n    var_name: str,\n    value: ArrayLike,\n    edge_list: list[NWNEdge] | None = None,\n) -&gt; None\n</code></pre> <p>Set the state variable of the memristors (nanowire network wire junctions) in the network.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Name of the state variable(s) to set.</p> required <code>value</code> <code>ndarray or scalar</code> <p>Value to set the state variable(s) to.</p> required <code>edge_list</code> <code>list of edges</code> <p>List of edges to set the state variable for. If None, all wire junction edges will be used. Should be the same length as the value array.</p> <code>None</code> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def set_state_var(\n    self,\n    var_name: str,\n    value: npt.ArrayLike,\n    edge_list: list[NWNEdge] | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the state variable of the memristors (nanowire network wire\n    junctions) in the network.\n\n    Parameters\n    ----------\n    var_name : str\n        Name of the state variable(s) to set.\n\n    value : ndarray or scalar\n        Value to set the state variable(s) to.\n\n    edge_list : list of edges, optional\n        List of edges to set the state variable for. If None, all wire\n        junction edges will be used. Should be the same length as the value\n        array.\n\n    \"\"\"\n    value = np.atleast_1d(value)\n\n    if var_name not in self.state_vars:\n        cls = self.__class__\n        raise ParameterNotSetError(\n            f\"'{var_name}' is not in {cls.__qualname__}.state_vars (currently is {self.state_vars}).\"\n            f\"\\nDid you set it using {cls.__qualname__}.state_vars = ['{var_name}', ...]?\"\n        )\n\n    edge_list = self.wire_junctions if edge_list is None else edge_list\n\n    # Set the state variable for the given edges to the same value...\n    if value.size == 1:\n        nx.set_edge_attributes(\n            self, {edge: {var_name: value[0]} for edge in edge_list}\n        )\n\n    # or to different values\n    elif value.size == len(edge_list):\n        nx.set_edge_attributes(\n            self,\n            {\n                edge: {var_name: value[i]}\n                for i, edge in enumerate(edge_list)\n            },\n        )\n\n    else:\n        raise ValueError(\n            f\"Length of value array ({value.size}) does not match the number of edges ({len(edge_list)}).\"\n        )\n\n    self._state_vars_is_set[var_name] = True\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.to_MNR","title":"to_MNR","text":"<pre><code>to_MNR() -&gt; None\n</code></pre> <p>Converts the NWN to the multi-nodal representation (MNR).</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def to_MNR(self) -&gt; None:\n    \"\"\"Converts the NWN to the multi-nodal representation (MNR).\"\"\"\n    convert_NWN_to_MNR(self)\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.update_resistance","title":"update_resistance","text":"<pre><code>update_resistance(\n    state_var_vals: ArrayLike | list[ArrayLike],\n    edge_list: list[NWNEdge] | None = None,\n) -&gt; None\n</code></pre> <p>Update the resistance of the nanowire network based on the provided state variable values. The resistance function should be set before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>state_var_vals</code> <code>ndarray or list of ndarrays</code> <p>An array of values of the state variables to use in the resistance function. The should be in the same order as the state variables. If the resistance function takes multiple state variables, pass a list of arrays in the same order as <code>NanowireNetwork.state_vars</code>.</p> required <code>edge_list</code> <code>list of edges</code> <p>List of edges to update the resistance for. If None, all wire junction edges will be used. In this case, the length of the <code>state_var_vals</code> array should be the same as the number of wire junctions.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of updated resistance values for each edge in the edge_list.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def update_resistance(\n    self,\n    state_var_vals: npt.ArrayLike | list[npt.ArrayLike],\n    edge_list: list[NWNEdge] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the resistance of the nanowire network based on the provided\n    state variable values. The resistance function should be set before\n    calling this method.\n\n    Parameters\n    ----------\n    state_var_vals : ndarray or list of ndarrays\n        An array of values of the state variables to use in the resistance\n        function. The should be in the same order as the state variables.\n        If the resistance function takes multiple state variables, pass a\n        list of arrays in the same order as `NanowireNetwork.state_vars`.\n\n    edge_list : list of edges, optional\n        List of edges to update the resistance for. If None, all wire\n        junction edges will be used. In this case, the length of the\n        `state_var_vals` array should be the same as the number of wire\n        junctions.\n\n    Returns\n    -------\n    ndarray\n        Array of updated resistance values for each edge in the edge_list.\n\n    \"\"\"\n    if self.resistance_function is None:\n        raise ParameterNotSetError(\n            \"Resistance function attribute must be set before updating resistance.\"\n        )\n\n    if not isinstance(state_var_vals, list):\n        state_var_vals = [state_var_vals]\n\n    if edge_list is None:\n        edge_list = self.wire_junctions\n\n    R = self.resistance_function(self, *state_var_vals)\n    attrs = {\n        edge: {\"conductance\": 1 / R[i]} for i, edge in enumerate(edge_list)\n    }\n    nx.set_edge_attributes(self, attrs)\n\n    return R\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.NanowireNetwork.wire_junction_indices","title":"wire_junction_indices  <code>cached</code>","text":"<pre><code>wire_junction_indices() -&gt; (\n    tuple[list[NWNNodeIndex], list[NWNNodeIndex]]\n)\n</code></pre> <p>Return the start and end indices of the wire junctions in the network as a tuple of lists.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>@lru_cache\ndef wire_junction_indices(\n    self,\n) -&gt; tuple[list[NWNNodeIndex], list[NWNNodeIndex]]:\n    \"\"\"\n    Return the start and end indices of the wire junctions in the network\n    as a tuple of lists.\n\n    \"\"\"\n    return np.asarray(self.get_index_from_edge(self.wire_junctions)).T\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.ParameterNotSetError","title":"ParameterNotSetError","text":"<pre><code>ParameterNotSetError(\n    message: str, param: Any | None = None\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when an parameter that needs to used has not been set yet.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>Name of the parameter that needs to be set.</p> <code>None</code> <code>message</code> <code>str</code> <p>Explanation of the error.</p> required Source code in <code>mnns/nanowire_network.py</code> <pre><code>def __init__(self, message: str, param: Any | None = None):\n    super().__init__(message)\n    self.param = param\n</code></pre>"},{"location":"reference/mnns/nanowire_network/#mnns.nanowire_network.create_NWN","title":"create_NWN","text":"<pre><code>create_NWN(\n    wire_length: float = 7.0 / 7,\n    shape: tuple[float, float] = (50.0 / 7, 50.0 / 7),\n    density: float = 0.3 * 7**2,\n    seed: int = None,\n    conductance: float = 0.1 / 0.1,\n    capacitance: float = 1000,\n    diameter: float = 50.0 / 50.0,\n    resistivity: float = 22.6 / 22.6,\n    units: dict[str, float] = None,\n    angle_dist: str = \"uniform\",\n    angle_kwargs: dict | None = None,\n) -&gt; NanowireNetwork\n</code></pre> <p>Create a nanowire network represented by a NetworkX graph. Wires are represented by the graph's vertices, while the wire junctions are represented by the graph's edges.</p> <p>The nanowire network starts in the junction-dominated assumption (JDA), but can be converted to the multi-nodal representation (MNR) after creation.</p> <p>The desired density may not be attainable with the given shape, as there can only be a integer number of wires. Thus, the closest density to an integer number of wires is used and stored as an attribute (see NWN Attributes for more information).</p> <p>See <code>mnns.NWNUnits</code> for the units used by the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>wire_length</code> <code>float</code> <p>Length of each nanowire. Given in units of l0.</p> <code>7.0 / 7</code> <code>shape</code> <code>2-tuple of float</code> <p>The shape of the nanowire network given in units of l0. Assumed to have the shape of (x-length, y-length).</p> <p>The x direction is labeled <code>length</code>, while the y direction is labeled <code>width</code>.</p> <code>(50.0 / 7, 50.0 / 7)</code> <code>density</code> <code>float</code> <p>Density of nanowires in the area determined by the width. Given in units of (l0)^-2.</p> <code>0.3 * 7 ** 2</code> <code>seed</code> <code>int</code> <p>Seed for random nanowire generation.</p> <code>None</code> <code>conductance</code> <code>float</code> <p>The junction conductance of the nanowires where they intersect. Given in units of (Ron)^-1.</p> <code>0.1 / 0.1</code> <code>capacitance</code> <code>float</code> <p>The junction capacitance of the nanowires where they intersect. Given in microfarads. (Currently unused)</p> <code>1000</code> <code>diameter</code> <code>float</code> <p>The diameter of each nanowire. Given in units of D0.</p> <code>50.0 / 50.0</code> <code>resistivity</code> <code>float</code> <p>The resistivity of each nanowire. Given in units of rho0.</p> <code>22.6 / 22.6</code> <code>units</code> <code>dict</code> <p>Dictionary of custom base units. Defaults to None which will use the default units given in <code>units.py</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>NWN</code> <code>Graph</code> <p>The created random nanowire network.</p> Source code in <code>mnns/nanowire_network.py</code> <pre><code>def create_NWN(\n    wire_length: float = (7.0 / 7),\n    shape: tuple[float, float] = ((50.0 / 7), (50.0 / 7)),\n    density: float = (0.3 * 7**2),\n    seed: int = None,\n    conductance: float = (0.1 / 0.1),\n    capacitance: float = 1000,\n    diameter: float = (50.0 / 50.0),\n    resistivity: float = (22.6 / 22.6),\n    units: dict[str, float] = None,\n    angle_dist: str = \"uniform\",\n    angle_kwargs: dict | None = None,\n) -&gt; NanowireNetwork:\n    \"\"\"\n    Create a nanowire network represented by a NetworkX graph. Wires are\n    represented by the graph's vertices, while the wire junctions are\n    represented by the graph's edges.\n\n    The nanowire network starts in the junction-dominated assumption (JDA), but\n    can be converted to the multi-nodal representation (MNR) after creation.\n\n    The desired density may not be attainable with the given shape, as there\n    can only be a integer number of wires. Thus, the closest density to an\n    integer number of wires is used and stored as an attribute (see\n    [NWN Attributes](../../attributes.md) for more information).\n\n    See [`mnns.NWNUnits`](units.md#mnns.units.NWNUnits) for the units used by\n    the parameters.\n\n    Parameters\n    ----------\n    wire_length : float, optional\n        Length of each nanowire. Given in units of l0.\n\n    shape : 2-tuple of float\n        The shape of the nanowire network given in units of l0. Assumed to\n        have the shape of (x-length, y-length).\n\n        The x direction is labeled `length`, while the y direction is labeled\n        `width`.\n\n    density : float, optional\n        Density of nanowires in the area determined by the width.\n        Given in units of (l0)^-2.\n\n    seed : int, optional\n        Seed for random nanowire generation.\n\n    conductance : float, optional\n        The junction conductance of the nanowires where they intersect.\n        Given in units of (Ron)^-1.\n\n    capacitance : float, optional\n        The junction capacitance of the nanowires where they intersect.\n        Given in microfarads. (Currently unused)\n\n    diameter : float, optional\n        The diameter of each nanowire. Given in units of D0.\n\n    resistivity : float, optional\n        The resistivity of each nanowire. Given in units of rho0.\n\n    units : dict, optional\n        Dictionary of custom base units. Defaults to None which will use the\n        default units given in `units.py`\n\n    Returns\n    -------\n    NWN : Graph\n        The created random nanowire network.\n\n    \"\"\"\n    # Find total area in (l0)^2 of the nanowire network\n    length = shape[0]\n    width = shape[1]\n    area = shape[0] * shape[1]\n\n    # Get closest density with an integer number of wires.\n    wire_num = round(area * density)\n    density = wire_num / area\n\n    # Get characteristic units\n    units = NWNUnits(units)\n\n    # Create NWN graph\n    NWN = NanowireNetwork(\n        wire_length=wire_length,\n        length=length,\n        width=width,\n        shape=shape,\n        wire_density=density,\n        wire_num=0,\n        junction_conductance=conductance,\n        junction_capacitance=capacitance,\n        wire_diameter=diameter,\n        wire_resistivity=resistivity,\n        electrode_list=[],\n        lines=[],\n        type=\"JDA\",\n        units=units,\n        loc={},\n        node_indices={},\n    )\n\n    # Create seeded random generator for testing\n    rng = np.random.default_rng(seed)\n\n    # Create the underlying line that represent the nanowires\n    lines = []\n    for _ in range(wire_num):\n        lines.append(\n            create_line(\n                length=wire_length,\n                xmax=length,\n                ymax=width,\n                rng=rng,\n                angle_dist=angle_dist,\n                angle_kwargs=angle_kwargs,\n            )\n        )\n\n    # Create nanowire from lines\n    add_wires(NWN, lines, [False] * len(lines))\n\n    # Find junction density\n    NWN.graph[\"junction_density\"] = len(NWN.graph[\"loc\"].keys()) / area\n\n    return NWN\n</code></pre>"},{"location":"reference/mnns/nanowires/","title":"mnns.nanowires","text":""},{"location":"reference/mnns/nanowires/#mnns.nanowires","title":"mnns.nanowires","text":"<p>Functions to modify nanowire networks.</p> <p>Functions:</p> Name Description <code>add_electrodes</code> <p>Convenience function for adding electrodes on the edges of a network</p> <code>add_wires</code> <p>Adds wires to a given nanowire network in-place. Returns the nodes of the</p> <code>convert_NWN_to_MNR</code> <p>Converts a JDA NWN to an MNR NWN in-place.</p> <code>get_edge_indices</code> <p>Given a NWN and a list of edges, returns two lists: one of the indices of</p>"},{"location":"reference/mnns/nanowires/#mnns.nanowires.add_electrodes","title":"add_electrodes","text":"<pre><code>add_electrodes(\n    NWN: NanowireNetwork, *args\n) -&gt; list[JDANode]\n</code></pre> <p>Convenience function for adding electrodes on the edges of a network in-place. Returns the nodes of the added electrodes in order.</p> <p>Can be called in two ways:</p> <pre><code>add_electrodes(NWN, *str)\n    where *str are strings with values {\"left\", \"right\", \"top, \"bottom\"}\n\nadd_electrodes(NWN, *iterable)\n    where *iterable are iterables where first entry is a string (as\n    before) the second entry is number of electrodes on that side,\n    and the third entry is the spacing between the electrodes,\n    assumed to be in units of l0. An optional fourth entry can be\n    given which is a list of offsets: a float value for each electrode.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network.</p> required <code>*args</code> <p>See function description.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>new_wire_nodes</code> <code>list of tuples</code> <p>List of the newly added nodes. If strings were passed, the list follows the order passed. If iterables were passed, the list is ordered from left-to-right or bottom-to-top concatenated.</p> Source code in <code>mnns/nanowires.py</code> <pre><code>def add_electrodes(NWN: NanowireNetwork, *args) -&gt; list[JDANode]:\n    \"\"\"\n    Convenience function for adding electrodes on the edges of a network\n    in-place. Returns the nodes of the added electrodes in order.\n\n    Can be called in two ways:\n\n        add_electrodes(NWN, *str)\n            where *str are strings with values {\"left\", \"right\", \"top, \"bottom\"}\n\n        add_electrodes(NWN, *iterable)\n            where *iterable are iterables where first entry is a string (as\n            before) the second entry is number of electrodes on that side,\n            and the third entry is the spacing between the electrodes,\n            assumed to be in units of l0. An optional fourth entry can be\n            given which is a list of offsets: a float value for each electrode.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network.\n\n    *args\n        See function description.\n\n    Returns\n    -------\n    new_wire_nodes : list of tuples\n        List of the newly added nodes. If strings were passed, the list\n        follows the order passed. If iterables were passed, the list is\n        ordered from left-to-right or bottom-to-top concatenated.\n\n    \"\"\"\n    length = NWN.graph[\"length\"]\n    width = NWN.graph[\"width\"]\n    line_list = []\n    seen = []\n\n    # Method one\n    if all(isinstance(arg, str) for arg in args):\n        for side in args:\n            if side in seen:\n                raise ValueError(f\"Duplicate side: {side}\")\n            elif side == \"left\":\n                line_list.append(LineString([(0, 0), (0, width)]))\n            elif side == \"right\":\n                line_list.append(LineString([(length, 0), (length, width)]))\n            elif side == \"top\":\n                line_list.append(LineString([(0, width), (length, width)]))\n            elif side == \"bottom\":\n                line_list.append(LineString([(0, 0), (length, 0)]))\n            else:\n                raise ValueError(f\"Invalid side: {side}\")\n            seen.append(side)\n\n    # Method two\n    elif all(isinstance(arg, Iterable) for arg in args):\n        for itr in args:\n            # Unpack list\n            if len(itr) == 3:\n                side, num, spacing = itr\n                offsets = [0.0] * num\n            elif len(itr) == 4:\n                side, num, spacing, offsets = itr\n            else:\n                raise ValueError(\"Invalid arguments.\")\n\n            # Cannot have the same side twice\n            if side in seen:\n                raise ValueError(f\"Duplicate side: {side}\")\n\n            # Add electrodes\n            elif side == \"left\":\n                for i in range(num):\n                    delta = offsets[i]\n                    start = (i / num * width) + (spacing / 2)\n                    end = ((i + 1) / num * width) - (spacing / 2)\n                    line_list.append(\n                        LineString([(0, start + delta), (0, end + delta)])\n                    )\n            elif side == \"right\":\n                for i in range(num):\n                    delta = offsets[i]\n                    start = (i / num * width) + (spacing / 2)\n                    end = ((i + 1) / num * width) - (spacing / 2)\n                    line_list.append(\n                        LineString(\n                            [(length, start + delta), (length, end + delta)]\n                        )\n                    )\n            elif side == \"top\":\n                for i in range(num):\n                    delta = offsets[i]\n                    start = (i / num * length) + (spacing / 2)\n                    end = ((i + 1) / num * length) - (spacing / 2)\n                    line_list.append(\n                        LineString(\n                            [(start + delta, width), (end + delta, width)]\n                        )\n                    )\n            elif side == \"bottom\":\n                for i in range(num):\n                    delta = offsets[i]\n                    start = (i / num * length) + (spacing / 2)\n                    end = ((i + 1) / num * length) - (spacing / 2)\n                    line_list.append(\n                        LineString([(start + delta, 0), (end + delta, 0)])\n                    )\n            else:\n                raise ValueError(f\"Invalid side: {side}\")\n\n    else:\n        raise ValueError(\n            \"Arguments after NWN must be all strings or all lists.\"\n        )\n\n    # Add wires to the network\n    new_wire_nodes = add_wires(NWN, line_list, [True] * len(line_list))\n    return new_wire_nodes\n</code></pre>"},{"location":"reference/mnns/nanowires/#mnns.nanowires.add_wires","title":"add_wires","text":"<pre><code>add_wires(\n    NWN: NanowireNetwork,\n    lines: list[LineString],\n    electrodes: list[bool],\n    resistance: float = None,\n) -&gt; list[JDANode]\n</code></pre> <p>Adds wires to a given nanowire network in-place. Returns the nodes of the added wires in order.</p> <p>Currently, adding a wire that already exists breaks things.</p> <p>Also, adding wires to a MNR NWN does not work yet.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network to add wires to.</p> required <code>lines</code> <code>list of LineStrings</code> <p>A list of Shapely LineStrings, representing nanowires, to be added.</p> required <code>electrodes</code> <code>list of bool</code> <p>A list of boolean values specifying whether or not the corresponding nanowire in <code>lines</code> is an electrode.</p> required <code>resistance</code> <code>float</code> <p>Junction resistances of the added wires.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>new_wire_nodes</code> <code>list of tuples</code> <p>List of the newly added nodes in the same order in <code>lines</code>.</p> Source code in <code>mnns/nanowires.py</code> <pre><code>def add_wires(\n    NWN: NanowireNetwork,\n    lines: list[LineString],\n    electrodes: list[bool],\n    resistance: float = None,\n) -&gt; list[JDANode]:\n    \"\"\"\n    Adds wires to a given nanowire network in-place. Returns the nodes of the\n    added wires in order.\n\n    Currently, adding a wire that already exists breaks things.\n\n    Also, adding wires to a MNR NWN does not work yet.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network to add wires to.\n\n    lines : list of LineStrings\n        A list of Shapely LineStrings, representing nanowires, to be added.\n\n    electrodes : list of bool\n        A list of boolean values specifying whether or not the corresponding\n        nanowire in `lines` is an electrode.\n\n    resistance : float, optional\n        Junction resistances of the added wires.\n\n    Returns\n    -------\n    new_wire_nodes : list of tuples\n        List of the newly added nodes in the same order in `lines`.\n\n    \"\"\"\n    if NWN.graph[\"type\"] != \"JDA\":\n        raise NotImplementedError(\"Only JDA is currently supported\")\n\n    new_wire_num = len(lines)\n\n    if new_wire_num != len(electrodes):\n        raise ValueError(\n            \"Length of new lines list must equal length of electrode boolean list.\"\n        )\n\n    # Update wire number in NWN\n    start_ind = NWN.graph[\"wire_num\"]\n    NWN.graph[\"wire_num\"] += new_wire_num\n\n    # Keep track of new wires\n    new_wire_nodes = []\n\n    # Add wires to NWN\n    for i in range(new_wire_num):\n        # Create new node\n        NWN.graph[\"lines\"].append(lines[i])\n        new_wire_nodes.append((start_ind + i,))\n        NWN.add_node((start_ind + i,), electrode=electrodes[i])\n\n        # Keep track of the electrodes\n        if electrodes[i]:\n            NWN.graph[\"electrode_list\"].append((start_ind + i,))\n\n        # Find intersects\n        intersect_dict = find_line_intersects(start_ind + i, NWN.graph[\"lines\"])\n\n        # Add edges to NWN\n        conductance = (\n            1 / resistance\n            if resistance is not None\n            else NWN.graph[\"junction_conductance\"]\n        )\n        NWN.add_edges_from(\n            [((key[0],), (key[1],)) for key in intersect_dict.keys()],\n            conductance=conductance,\n            capacitance=NWN.graph[\"junction_capacitance\"],\n            type=\"junction\",\n        )\n        NWN.graph[\"loc\"].update(intersect_dict)\n\n        # Update index lookup\n        NWN.graph[\"node_indices\"].update({(start_ind + i,): start_ind + i})\n\n    # Update wire density\n    area = NWN.graph[\"length\"] * NWN.graph[\"width\"]\n    NWN.graph[\"wire_density\"] = (\n        NWN.graph[\"wire_num\"] - len(NWN.graph[\"electrode_list\"])\n    ) / area\n\n    # Clear current junction list\n    del NWN.wire_junctions\n\n    return new_wire_nodes\n</code></pre>"},{"location":"reference/mnns/nanowires/#mnns.nanowires.convert_NWN_to_MNR","title":"convert_NWN_to_MNR","text":"<pre><code>convert_NWN_to_MNR(NWN: NanowireNetwork)\n</code></pre> <p>Converts a JDA NWN to an MNR NWN in-place.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>JDA nanowire network.</p> required Source code in <code>mnns/nanowires.py</code> <pre><code>def convert_NWN_to_MNR(NWN: NanowireNetwork):\n    \"\"\"\n    Converts a JDA NWN to an MNR NWN in-place.\n\n    Parameters\n    ----------\n    NWN : nx.Graph\n        JDA nanowire network.\n\n    \"\"\"\n    if NWN.graph[\"type\"] == \"MNR\":\n        print(\"Nanowire network already MNR.\")\n        return\n\n    NWN.graph[\"type\"] = \"MNR\"\n    l0 = NWN.graph[\"units\"][\"l0\"]\n    rho0 = NWN.graph[\"units\"][\"rho0\"]\n    Ron = NWN.graph[\"units\"][\"Ron\"]\n    D0 = NWN.graph[\"units\"][\"D0\"]\n    A0 = D0 * D0\n\n    rho = NWN.graph[\"wire_resistivity\"]\n    D = NWN.graph[\"wire_diameter\"]\n    A = np.pi / 4 * D * D\n\n    for i in range(NWN.graph[\"wire_num\"]):\n        # Get the junctions for a wire\n        junctions = NWN.edges((i,))\n\n        # Get location of the junction for a wire\n        junction_locs = {\n            edge: NWN.graph[\"loc\"][tuple(sorted([edge[0][0], edge[1][0]]))]\n            for edge in junctions\n        }\n\n        # Add junctions as part of the LineString that makes up the wire\n        NWN.graph[\"lines\"][i], ordering = add_points_to_line(\n            NWN.graph[\"lines\"][i], junction_locs.values(), return_ordering=True\n        )\n\n        # If wire is electrode, move on to the next wire\n        if (i,) in NWN.graph[\"electrode_list\"]:\n            continue\n\n        # Split nodes into subnodes representing the junctions on the wires\n        for j, (edge, loc) in enumerate(junction_locs.items()):\n            # Find connecting node\n            other_node = edge[~edge.index((i,))]\n\n            # Get old edge attributes\n            old_attributes = NWN.edges[edge]\n\n            # Create the replacing MNR node and edge\n            NWN.add_node((i, j), loc=loc, electrode=False)\n            NWN.add_edge((i, j), other_node, **old_attributes)\n\n        # Remove old JDA node, only if it had connections\n        if len(junction_locs) &gt;= 1:\n            NWN.remove_node((i,))\n\n        # Add edges between subnodes\n        for ind, next_ind in zip(ordering, ordering[1:]):\n            # Find inner-wire resistance\n            L = NWN.nodes[(i, ind)][\"loc\"].distance(\n                NWN.nodes[(i, next_ind)][\"loc\"]\n            )\n            wire_conductance = (Ron * A0 * A) / (rho0 * l0 * rho * L * 1e3)\n\n            # Add inner-wire edge\n            NWN.add_edge(\n                (i, ind),\n                (i, next_ind),\n                conductance=wire_conductance,\n                capacitance=0,\n                type=\"inner\",\n            )\n\n    # Update index lookup\n    NWN.graph[\"node_indices\"] = {\n        node: ind for ind, node in enumerate(sorted(NWN.nodes()))\n    }\n</code></pre>"},{"location":"reference/mnns/nanowires/#mnns.nanowires.get_edge_indices","title":"get_edge_indices","text":"<pre><code>get_edge_indices(\n    NWN: NanowireNetwork, edges: list[NWNEdge]\n) -&gt; tuple[list[NWNNodeIndex], list[NWNNodeIndex]]\n</code></pre> <p>Given a NWN and a list of edges, returns two lists: one of the indices of the first nodes in the input edge list, and one of the second.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire Network.</p> required <code>edges</code> <code>list of tuples</code> <p>List of edges to find the indices of.</p> required Source code in <code>mnns/nanowires.py</code> <pre><code>def get_edge_indices(\n    NWN: NanowireNetwork, edges: list[NWNEdge]\n) -&gt; tuple[list[NWNNodeIndex], list[NWNNodeIndex]]:\n    \"\"\"\n    Given a NWN and a list of edges, returns two lists: one of the indices of\n    the first nodes in the input edge list, and one of the second.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire Network.\n\n    edges : list of tuples\n        List of edges to find the indices of.\n\n    \"\"\"\n    # JDA edge indices\n    if NWN.graph[\"type\"] == \"JDA\":\n        start_nodes, end_nodes = map(\n            list, zip(*[(*n1, *n2) for n1, n2 in edges])\n        )\n\n    # MNR edge indices\n    elif NWN.graph[\"type\"] == \"MNR\":\n        tmp = []\n        for key in NWN.graph[\"node_indices\"].keys():\n            if len(key) == 2:\n                tmp.append(key[1])\n            else:\n                tmp.append(0)\n\n        node_start_index = np.where(np.asarray(tmp) == 0)[0]\n\n        start_nodes, end_nodes = [], []\n        for n1, n2 in edges:\n            if len(n1) == 2:\n                start_nodes.append(node_start_index[n1[0]] + n1[1])\n            else:\n                start_nodes.append(node_start_index[n1[0]])\n            if len(n2) == 2:\n                end_nodes.append(node_start_index[n2[0]] + n2[1])\n            else:\n                end_nodes.append(node_start_index[n2[0]])\n\n    # Invalid NWN Type\n    else:\n        raise ValueError(\"Invalid NWN type.\")\n\n    return start_nodes, end_nodes\n</code></pre>"},{"location":"reference/mnns/plotting/","title":"mnns.plotting","text":""},{"location":"reference/mnns/plotting/#mnns.plotting","title":"mnns.plotting","text":"<p>Functions to plot nanowire networks.</p> <p>Functions:</p> Name Description <code>draw_NWN</code> <p>Draw the given nanowire network as a networkx graph. JDA drawing is more</p> <code>plot_NWN</code> <p>Plots a given nanowire network and returns the figure and axes.</p>"},{"location":"reference/mnns/plotting/#mnns.plotting.draw_NWN","title":"draw_NWN","text":"<pre><code>draw_NWN(\n    NWN: Graph,\n    figsize: tuple = None,\n    font_size: int = 8,\n    node_labels: ndarray = None,\n    fmt: str = \".2f\",\n    edge_colors: ndarray = None,\n    cbar_label: str = \"Colorbar\",\n    cmap=plt.cm.RdYlBu_r,\n) -&gt; tuple[Figure, Axes]\n</code></pre> <p>Draw the given nanowire network as a networkx graph. JDA drawing is more detailed as nodes can be given spacial locations. With MNR drawing, nodes will have random locations.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network to draw.</p> required <code>figsize</code> <code>tuple</code> <p>Figure size to be passed to <code>plt.subplots</code>.</p> <code>None</code> <code>font_size</code> <code>int</code> <p>Font size to be passed to <code>nx.draw</code>.</p> <code>8</code> <code>node_labels</code> <code>ndarray</code> <p>If supplied, these values will be display as node labels instead of the names of the nodes.</p> <code>None</code> <code>fmt</code> <code>str</code> <p>String formatting for node labels. Only used if sol is passed. Default: \".2f\".</p> <code>'.2f'</code> <code>edge_colors</code> <code>ndarray</code> <p>List of values to color the edges. Edges are assumed to be in the same order as <code>NWN.edges</code>.</p> <code>None</code> <code>cbar_label</code> <code>str</code> <p>Label for the colorbar.</p> <code>'Colorbar'</code> <code>cmap</code> <code>colormap</code> <p>Matplotlib color map to use for the edges.</p> <code>RdYlBu_r</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>Figure object of the plot.</p> <code>ax</code> <code>Axes</code> <p>Axes object of the plot.</p> Source code in <code>mnns/plotting.py</code> <pre><code>def draw_NWN(\n    NWN: nx.Graph,\n    figsize: tuple = None,\n    font_size: int = 8,\n    node_labels: np.ndarray = None,\n    fmt: str = \".2f\",\n    edge_colors: np.ndarray = None,\n    cbar_label: str = \"Colorbar\",\n    cmap=plt.cm.RdYlBu_r,\n) -&gt; tuple[Figure, Axes]:\n    \"\"\"\n    Draw the given nanowire network as a networkx graph. JDA drawing is more\n    detailed as nodes can be given spacial locations. With MNR drawing, nodes\n    will have random locations.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network to draw.\n\n    figsize : tuple, optional\n        Figure size to be passed to `plt.subplots`.\n\n    font_size : int, optional\n        Font size to be passed to `nx.draw`.\n\n    node_labels : ndarray, optional\n        If supplied, these values will be display as node labels\n        instead of the names of the nodes.\n\n    fmt : str, optional\n        String formatting for node labels. Only used if sol is passed.\n        Default: \".2f\".\n\n    edge_colors : ndarray, optional\n        List of values to color the edges. Edges are assumed to be in the\n        same order as `NWN.edges`.\n\n    cbar_label : str, optional\n        Label for the colorbar.\n\n    cmap : colormap, optional\n        Matplotlib color map to use for the edges.\n\n    Returns\n    -------\n    fig : Figure\n        Figure object of the plot.\n\n    ax : Axes\n        Axes object of the plot.\n\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if NWN.graph[\"type\"] == \"JDA\":\n        kwargs = dict()\n\n        # Nodes are placed at the center of the wire\n        kwargs.update(\n            {\n                \"pos\": {\n                    (i,): np.asarray(*NWN.graph[\"lines\"][i].centroid.coords)\n                    for i in range(NWN.graph[\"wire_num\"])\n                }\n            }\n        )\n\n        # Label node voltages if sol is given, else just label as nodes numbers\n        if node_labels is not None:\n            kwargs.update(\n                {\n                    \"labels\": {\n                        (key,): f\"{value:{fmt}}\"\n                        for key, value in zip(\n                            range(NWN.graph[\"wire_num\"]), node_labels\n                        )\n                    }\n                }\n            )\n        else:\n            kwargs.update(\n                {\"labels\": {(i,): i for i in range(NWN.graph[\"wire_num\"])}}\n            )\n\n        # Add edges colors if weights are passed\n        if edge_colors is not None:\n            kwargs.update(\n                {\n                    \"edgelist\": NWN.edges,\n                    \"edge_color\": edge_colors,\n                    \"edge_cmap\": cmap,\n                }\n            )\n\n            # Add a colorbar to the network plot\n            norm = mpl.colors.Normalize(\n                vmin=np.nanmin(edge_colors), vmax=np.nanmax(edge_colors)\n            )\n\n            cax = fig.add_axes([0.95, 0.2, 0.02, 0.6])\n            cb = mpl.colorbar.ColorbarBase(cax, norm=norm, cmap=cmap)\n            cb.set_label(cbar_label)\n\n        else:\n            kwargs.update({\"edge_color\": \"r\"})\n\n        # Add node formatting\n        kwargs.update({\"ax\": ax, \"font_size\": font_size, \"node_size\": 40})\n\n        nx.draw(NWN, **kwargs)\n\n    elif NWN.graph[\"type\"] == \"MNR\":\n        kwargs = {}\n        if node_labels is not None:\n            labels = {\n                node: f\"{value:{fmt}}\"\n                for node, value in zip(sorted(NWN.nodes()), node_labels)\n            }\n            kwargs.update({\"labels\": labels})\n        else:\n            kwargs.update({\"with_labels\": True})\n\n        nx.draw(\n            NWN,\n            ax=ax,\n            node_size=40,\n            font_size=font_size,\n            edge_color=\"r\",\n            **kwargs,\n        )\n\n    else:\n        raise ValueError(\"Nanowire network has invalid type.\")\n\n    return fig, ax\n</code></pre>"},{"location":"reference/mnns/plotting/#mnns.plotting.plot_NWN","title":"plot_NWN","text":"<pre><code>plot_NWN(\n    NWN: Graph,\n    intersections: bool = True,\n    rnd_color: bool = False,\n    scaled: bool = False,\n    grid: bool = True,\n    xlabel: str = \"\",\n    ylabel: str = \"\",\n) -&gt; tuple[Figure, Axes]\n</code></pre> <p>Plots a given nanowire network and returns the figure and axes.</p> <p>Parameters:</p> Name Type Description Default <code>NWN</code> <code>Graph</code> <p>Nanowire network to plot.</p> required <code>intersections</code> <code>bool</code> <p>Whether or not to scatter plot the intersections as well. Defaults to true.</p> <code>True</code> <code>rnd_color</code> <code>bool</code> <p>Whether or not to randomize the colors of the plotted lines. Defaults to false.</p> <code>False</code> <code>scaled</code> <code>bool</code> <p>Whether or not to scale the plot by the characteristic values of the given nanowire network. Defaults to False.</p> <code>False</code> <code>grid</code> <code>bool</code> <p>Grid lines on plot. Defaults to true.</p> <code>True</code> <code>xlabel</code> <code>str</code> <p>x label string.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>y label string.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>Figure object of the plot.</p> <code>ax</code> <code>Axes</code> <p>Axes object of the plot.</p> Source code in <code>mnns/plotting.py</code> <pre><code>def plot_NWN(\n    NWN: nx.Graph,\n    intersections: bool = True,\n    rnd_color: bool = False,\n    scaled: bool = False,\n    grid: bool = True,\n    xlabel: str = \"\",\n    ylabel: str = \"\",\n) -&gt; tuple[Figure, Axes]:\n    \"\"\"\n    Plots a given nanowire network and returns the figure and axes.\n\n    Parameters\n    ----------\n    NWN : Graph\n        Nanowire network to plot.\n\n    intersections : bool, optional\n        Whether or not to scatter plot the intersections as well.\n        Defaults to true.\n\n    rnd_color : bool, optional\n        Whether or not to randomize the colors of the plotted lines.\n        Defaults to false.\n\n    scaled: bool, optional\n        Whether or not to scale the plot by the characteristic values of the\n        given nanowire network. Defaults to False.\n\n    grid: bool, optional\n        Grid lines on plot. Defaults to true.\n\n    xlabel: str, optional\n        x label string.\n\n    ylabel: str, optional\n        y label string.\n\n    Returns\n    -------\n    fig : Figure\n        Figure object of the plot.\n\n    ax : Axes\n        Axes object of the plot.\n\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(8, 6))\n    l0 = NWN.graph[\"units\"][\"l0\"]\n\n    # Plot intersection plots if required\n    if intersections:\n        ax.scatter(\n            *np.array(\n                [(point.x, point.y) for point in NWN.graph[\"loc\"].values()]\n            ).T,\n            zorder=10,\n            s=5,\n            c=\"blue\",\n        )\n\n    # Defaults to blue and pink lines, else random colors are used.\n    if rnd_color:\n        for i in range(NWN.graph[\"wire_num\"]):\n            ax.plot(*np.asarray(NWN.graph[\"lines\"][i].coords).T)\n    else:\n        for i in range(NWN.graph[\"wire_num\"]):\n            if (i,) in NWN.graph[\"electrode_list\"]:\n                ax.plot(\n                    *np.asarray(NWN.graph[\"lines\"][i].coords).T,\n                    c=\"xkcd:light blue\",\n                )\n            else:\n                ax.plot(*np.asarray(NWN.graph[\"lines\"][i].coords).T, c=\"pink\")\n\n    # Scale axes according to the characteristic values\n    if scaled:\n        ax.xaxis.set_major_formatter(\n            ticker.FuncFormatter(lambda x, pos: f\"{x * l0:.3g}\")\n        )\n        ax.yaxis.set_major_formatter(\n            ticker.FuncFormatter(lambda y, pos: f\"{y * l0:.3g}\")\n        )\n\n    # Other attributes\n    if grid:\n        ax.grid(alpha=0.25)\n    if xlabel:\n        ax.set_xlabel(xlabel)\n    if ylabel:\n        ax.set_ylabel(ylabel)\n\n    return fig, ax\n</code></pre>"},{"location":"reference/mnns/units/","title":"mnns.units","text":""},{"location":"reference/mnns/units/#mnns.units","title":"mnns.units","text":"<p>Characteristic units for a nanowire network.</p> <p>Classes:</p> Name Description <code>NWNUnits</code> <p>Class for characteristic units for a nanowire network. Acts similar to a</p> <p>Functions:</p> Name Description <code>get_units</code> <p>Deprecated. Use <code>mnns.NWNUnits</code></p>"},{"location":"reference/mnns/units/#mnns.units.NWNUnits","title":"NWNUnits","text":"<pre><code>NWNUnits(new_units: dict[str, float] = None)\n</code></pre> <p>Class for characteristic units for a nanowire network. Acts similar to a dictionary with key-value pairs to access units.</p> <p>The default units for the nanowire network are: <pre><code>units = mnns.NWNUnits()\nprint(units)\n      v0: 1.0     V, Voltage\n     Ron: 10.0    \u03a9, ON Junction resistance\n      l0: 7.0     \u03bcm, Wire length\n      D0: 50.0    nm, Wire diameter\n      w0: 10.0    nm, Junction length (2x Wire coating thickness)\n    rho0: 22.6    n\u03a9m, Wire resistivity\n     mu0: 0.01    \u03bcm^2 s^-1 V^-1, Ion mobility\nRoff_Ron: 160     Off-On Resistance ratio\n      i0: 0.1     A, Current\n      t0: 10000.0 \u03bcs, Time\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>new_units</code> <code>NWNUnits or dict</code> <p>Dictionary of any custom units to use. Only base units can be altered.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>units</code> <code>dict</code> <p>Dictionary of characteristic units.</p> Source code in <code>mnns/units.py</code> <pre><code>def __init__(self, new_units: dict[str, float] = None):\n    if isinstance(new_units, NWNUnits):\n        # Copy from previous NWNUnits instance\n        self.units = new_units.units.copy()\n        self.update_derived_units()\n\n    else:\n        # Set default and derived units\n        self.units = self.default_units.copy()\n        self.update_derived_units()\n\n        # Update units and derived units for any new units\n        if new_units is not None:\n            for key, value in new_units.items():\n                self[key] = value\n</code></pre>"},{"location":"reference/mnns/units/#mnns.units.get_units","title":"get_units","text":"<pre><code>get_units(\n    new_units: dict[str, float] = None,\n) -&gt; dict[str, float]\n</code></pre> <p>Deprecated. Use <code>mnns.NWNUnits</code> instead.</p> <p>Returns the characteristic units for a nanowire network.</p> <p>Parameters:</p> Name Type Description Default <code>new_units</code> <code>dict</code> <p>Dictionary of any custom units to use. Only base units can be altered.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>units</code> <code>dict</code> <p>Dictionary of characteristic units.</p> Source code in <code>mnns/units.py</code> <pre><code>def get_units(new_units: dict[str, float] = None) -&gt; dict[str, float]:\n    \"\"\"\n    Deprecated. Use [`mnns.NWNUnits`](units.md#mnns.units.NWNUnits)\n    instead.\n\n    Returns the characteristic units for a nanowire network.\n\n    Parameters\n    ----------\n    new_units : dict, optional\n        Dictionary of any custom units to use. Only base units can be altered.\n\n    Returns\n    -------\n    units : dict\n        Dictionary of characteristic units.\n\n    \"\"\"\n    if new_units is None:\n        new_units = dict()\n\n    # Base units\n    units = {  # Unit, Description\n        \"v0\": 1.0,  # V, Voltage\n        \"Ron\": 10.0,  # \u03a9, ON junction resistance\n        \"l0\": 7.0,  # \u03bcm, Wire length\n        \"D0\": 50.0,  # nm, Wire diameter\n        \"w0\": 10.0,  # nm, Junction length (2x Wire coating thickness)\n        \"rho0\": 22.6,  # n\u03a9m, Wire resistivity\n        \"mu0\": 1e-2,  # \u03bcm^2 s^-1 V^-1, Ion mobility\n        \"Roff_Ron\": 160,  # none, Off-On Resistance ratio\n    }\n\n    # Add any custom units\n    units.update(new_units)\n\n    # Derived units\n    units[\"i0\"] = units[\"v0\"] / units[\"Ron\"]  # A, Current\n    units[\"t0\"] = units[\"w0\"] ** 2 / (units[\"mu0\"] * units[\"v0\"])  # \u03bcs, Time\n\n    return units\n</code></pre>"}]}